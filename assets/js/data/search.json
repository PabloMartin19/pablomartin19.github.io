[
  
  {
    "title": "Cifrado asimétrico con gpg y openssl",
    "url": "/posts/gpg-openssl/",
    "categories": "Seguridad, Criptografía",
    "tags": "Criptografía",
    "date": "2024-12-12 21:15:00 +0100",
    





    
    "snippet": "Tarea 1: Generación de claves (gpg)1. Genera un par de claves (pública y privada). ¿En que directorio se guarda las claves de un usuario?Para generar el par de claves haremos uso de la opción --gen...",
    "content": "Tarea 1: Generación de claves (gpg)1. Genera un par de claves (pública y privada). ¿En que directorio se guarda las claves de un usuario?Para generar el par de claves haremos uso de la opción --gen-key de gpg:pavlo@debian:~()$ gpg --gen-keygpg (GnuPG) 2.2.40; Copyright (C) 2022 g10 Code GmbHThis is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.Nota: Usa \"gpg --full-generate-key\" para el diálogo completo de generación de clave.GnuPG debe construir un ID de usuario para identificar su clave.Nombre y apellidos:Primero, se nos solicitará que ingresemos nuestro nombre completo, incluyendo los apellidos, con el objetivo de diferenciar nuestra clave de las demás. Escribiremos esta información y procederemos al siguiente paso.Nombre y apellidos: Pablo Martín HidalgoDirección de correo electrónico: pmartinhidalgo19@gmail.comA continuación, será necesario proporcionar nuestra dirección de correo electrónico. La ingresaremos y continuaremos con el proceso.Está usando el juego de caracteres 'utf-8'.Ha seleccionado este ID de usuario:    \"Pablo Martín Hidalgo &lt;pmartinhidalgo19@gmail.com&gt;\"¿Cambia (N)ombre, (D)irección o (V)ale/(S)alir?Cuando hayamos completado estos datos, se nos mostrará un resumen para confirmarlos. Si todo es correcto, seleccionaremos la opción “V” para confirmar.¿Cambia (N)ombre, (D)irección o (V)ale/(S)alir? VEs necesario generar muchos bytes aleatorios. Es una buena idea realizaralguna otra tarea (trabajar en otra ventana/consola, mover el ratón, usarla red y los discos) durante la generación de números primos. Esto da algenerador de números aleatorios mayor oportunidad de recoger suficienteentropía.En este momento, se nos pedirá que configuremos una frase de paso que protegerá nuestra clave privada. Será necesario ingresarla dos veces para confirmar y, una vez hecho esto, se iniciará el proceso de generación del par de claves. Como se indica en el mensaje mostrado, es recomendable realizar alguna actividad en nuestro equipo durante este proceso para ayudar a generar entropía.gpg: creado el directorio '/home/pavlo/.gnupg/openpgp-revocs.d'gpg: certificado de revocación guardado como '/home/pavlo/.gnupg/openpgp-revocs.d/9D0AB661A8C5977C20924020130D7BAF24114BE7.rev'claves pública y secreta creadas y firmadas.pub   rsa3072 2024-12-12 [SC] [caduca: 2026-12-12]      9D0AB661A8C5977C20924020130D7BAF24114BE7uid                      Pablo Martín Hidalgo &lt;pmartinhidalgo19@gmail.com&gt;sub   rsa3072 2024-12-12 [E] [caduca: 2026-12-12]Una vez completada la generación, nuestro par de claves estará creado y añadido con total confianza a nuestro keyring pubring.kbx, que se encuentra ubicado en el directorio personal dentro de la carpeta .gnupg/. Además, de manera automática se habrá generado un certificado de revocación en .gnupg/openpgp-revocs.d/. Este certificado será útil en caso de que nuestra clave privada sea comprometida o si decidimos dejar de usar este par de claves, permitiendo informar a otros usuarios que la clave pública asociada no debe ser utilizada más para cifrar.2. Lista las claves públicas que tienes en tu almacén de claves. Explica los distintos datos que nos muestra. ¿Cómo deberías haber generado las claves para indicar, por ejemplo, que tenga un 1 mes de validez?Para listar las claves públicas haremos uso de la opción --list-keys de gpg:pavlo@debian:~()$ gpg --list-keysgpg: comprobando base de datos de confianzagpg: marginals needed: 3  completes needed: 1  trust model: pgpgpg: nivel: 0  validez:   1  firmada:   0  confianza: 0-, 0q, 0n, 0m, 0f, 1ugpg: siguiente comprobación de base de datos de confianza el: 2026-12-12/home/pavlo/.gnupg/pubring.kbx------------------------------pub   rsa3072 2024-12-12 [SC] [caduca: 2026-12-12]      9D0AB661A8C5977C20924020130D7BAF24114BE7uid        [  absoluta ] Pablo Martín Hidalgo &lt;pmartinhidalgo19@gmail.com&gt;sub   rsa3072 2024-12-12 [E] [caduca: 2026-12-12]Si quisiéramos generar claves con un período de validez específico, podríamos haber utilizado la opción –full-gen-key de GPG. Esto nos habría mostrado un mensaje donde se solicita configurar el tiempo de validez.pavlo@debian:~()$ gpg --full-generate-keygpg (GnuPG) 2.2.40; Copyright (C) 2022 g10 Code GmbHThis is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.Por favor seleccione tipo de clave deseado:   (1) RSA y RSA (por defecto)   (2) DSA y ElGamal   (3) DSA (sólo firmar)   (4) RSA (sólo firmar)  (14) Existing key from cardSu elección: las claves RSA pueden tener entre 1024 y 4096 bits de longitud.¿De qué tamaño quiere la clave? (3072) El tamaño requerido es de 3072 bitsPor favor, especifique el período de validez de la clave.         0 = la clave nunca caduca      &lt;n&gt;  = la clave caduca en n días      &lt;n&gt;w = la clave caduca en n semanas      &lt;n&gt;m = la clave caduca en n meses      &lt;n&gt;y = la clave caduca en n años¿Validez de la clave (0)?En este punto, podríamos haber indicado la duración deseada siguiendo las opciones que se nos presentan. Por ejemplo, para establecer una validez de un mes, podríamos haber ingresado 30, 4w o 1m, ya que todas estas opciones representan el mismo intervalo de tiempo.3. Lista las claves privadas de tu almacén de clavesPara listar las claves privadas haremos uso de la opción --list-secret-keys de gpg:pavlo@debian:~()$ gpg --list-secret-keys/home/pavlo/.gnupg/pubring.kbx------------------------------sec   rsa3072 2024-12-12 [SC] [caduca: 2026-12-12]      9D0AB661A8C5977C20924020130D7BAF24114BE7uid        [  absoluta ] Pablo Martín Hidalgo &lt;pmartinhidalgo19@gmail.com&gt;ssb   rsa3072 2024-12-12 [E] [caduca: 2026-12-12]Cuando listamos las claves públicas obtuvimos las siguientes abreviaturas:  pub: Clave primaria pública (public primary key).  uid: Identificador único (unique identifier).  sub: Clave secundaria pública (public sub-key).Al listar las claves privadas con gpg --list-secret-keys, las abreviaturas mostradas fueron:  sec: Clave primaria privada (secret primary key).  uid: Identificador único (unique identifier).  ssb: Clave secundaria privada (secret sub-key).En criptografía asimétrica trabajamos con pares de claves: una clave pública para encriptar o comprobar firmas, y una clave privada (secreta) para desencriptar o firmar, respectivamente.Cuando generamos un par de claves OpenPGP con GnuPG, se crean por defecto:  Un par de claves primario o master key:          Contiene uno o más identificadores de usuario (user-IDs), como nombre, apellidos y correo electrónico.      Se utiliza para firmar o comprobar firmas, ya que es una prueba de identidad.      La clave privada de este par debe protegerse cuidadosamente.        Un par de claves secundario:          Está firmado por el par de claves primario, lo que garantiza que pertenece al user-ID.      Se utiliza exclusivamente para encriptar o desencriptar información.      La separación entre pares de claves maestros y secundarios permite revocar estos últimos sin afectar a los primeros y almacenarlos por separado. En esencia, los pares de claves secundarios son independientes, pero están vinculados al par maestro.Tarea 2: Importar/exportar clave pública (gpg)1. Exporta tu clave pública en formato ASCII, guárdalo en un archivo “nombre_apellido.asc” y envíalo al compañero con el que vas a hacer esta práctica.Para exportar nuestras claves públicas, utilizaremos la opción --export de gpg junto con la opción -a &lt;nombre&gt;. Esto generará una salida en formato ASCII que puede ser redirigida a un archivo.El &lt;nombre&gt; que debemos especificar es el mismo que introdujimos al generar el par de claves (generalmente nuestro nombre o dirección de correo electrónico).El comando a ejecutar es el siguiente:pavlo@debian:~()$ gpg --export -a \"Pablo Martín Hidalgo\" &gt; pablo_martin.ascpavlo@debian:~()$ ls -l pablo_martin.asc -rw-r--r-- 1 pavlo pavlo 2476 dic 12 18:33 pablo_martin.ascEsta práctica la he realizado junto a Jose Antonio Canalo, así que le he enviado mis claves públicas exportadas a través de Discord:2. Importa las claves públicas recibidas de vuestro compañeroAl igual que yo, Jose me ha pasado su clave pública por Discord y como vemos ya la tengo descargada:Para importar las claves públicas de otro usuario, utilizaremos la opción --import de gpg, seguida del nombre del archivo que contiene la clave pública. En este caso, el archivo a importar es el que hemos recibido, por ejemplo, joseantoniocanalo.asc.El comando a ejecutar sería:pavlo@debian:~()$ gpg --import joseantoniocanalo.asc gpg: clave 5DD99C6F8D4E1C65: clave pública \"jose antonio Canalo Gonzalez &lt;joseantoniocgonzalez83@gmail.com&gt;\" importadagpg: Cantidad total procesada: 1gpg:               importadas: 1Como vemos nos ha devuelto un mensaje por pantalla informando que las claves públicas de Jose han sido correctamente importadas.3. Comprueba que las claves se han incluido correctamente en vuestro keyringDe nuevo, volveremos a hacer uso de opción --list-keys de gpg para verificar que las claves públicas han sido correctamente importadas a nuestro keyring:pavlo@debian:~()$ gpg --list-keys/home/pavlo/.gnupg/pubring.kbx------------------------------pub   rsa3072 2024-12-12 [SC] [caduca: 2026-12-12]      9D0AB661A8C5977C20924020130D7BAF24114BE7uid        [  absoluta ] Pablo Martín Hidalgo &lt;pmartinhidalgo19@gmail.com&gt;sub   rsa3072 2024-12-12 [E] [caduca: 2026-12-12]pub   rsa3072 2024-12-12 [SC] [caduca: 2026-12-12]      279F1D439CE7DA18300BF21D5DD99C6F8D4E1C65uid        [desconocida] jose antonio Canalo Gonzalez &lt;joseantoniocgonzalez83@gmail.com&gt;sub   rsa3072 2024-12-12 [E] [caduca: 2026-12-12]Y efectivamente, las claves públicas de Jose han sido correctamente importadas a nuestro keyring en .gnupg/pubring.kbx.Tarea 3: Cifrado asimétrico con claves públicas (gpg)1. Cifraremos un archivo cualquiera y lo remitiremos por email a uno de nuestros compañeros que nos proporcionó su clave públicaEn este ejemplo, tengo un archivo llamado mensaje_encriptado.txt, el cual quiero cifrar con la clave pública de Jose para enviárselo de forma segura. Para ello, utilizaremos la opción -e de gpg junto con:  -u &lt;remitente&gt;: Indica quién es el remitente, especificando la clave privada que se usará para firmar, si es necesario.  -r &lt;destinatario&gt;: Especifica el destinatario, cuya clave pública será usada para cifrar el archivo.El comando a ejecutar sería:pavlo@debian:~()$ gpg -e -u \"Pablo Martín Hidalgo\" -r \"jose antonio Canalo Gonzalez\" mensaje_encriptado.txtgpg: 6CB51A1718E6B9E9: No hay seguridad de que esta clave pertenezca realmenteal usuario que se nombrasub  rsa3072/6CB51A1718E6B9E9 2024-12-12 jose antonio Canalo Gonzalez &lt;joseantoniocgonzalez83@gmail.com&gt; Huella clave primaria: 279F 1D43 9CE7 DA18 300B  F21D 5DD9 9C6F 8D4E 1C65      Huella de subclave: F8AF 9D20 076C 877E DDEF  DE6B 6CB5 1A17 18E6 B9E9No es seguro que la clave pertenezca a la persona que se nombra en elidentificador de usuario. Si *realmente* sabe lo que está haciendo,puede contestar sí a la siguiente pregunta.¿Usar esta clave de todas formas? (s/N) sAl listar los archivos en el directorio utilizando el comando:pavlo@debian:~()$ ls -l | egrep mensaje_encriptado-rw-r--r--  1 pavlo pavlo   25 dic 12 18:45 mensaje_encriptado.txt-rw-r--r--  1 pavlo pavlo  507 dic 12 18:46 mensaje_encriptado.txt.gpgComo podemos observar ahora tenemos dos archivos, el original (mensaje_encriptado.txt) y el encriptado (mensaje_encriptado.txt.gpg).Tras ello, le enviaré dicho fichero a Jose por Discord:2. Nuestro compañero, a su vez, nos remitirá un archivo cifrado para que nosotros lo descifremos.Al igual que yo, Jose me ha pasado su mensaje cifrado por Discord:3. Tanto nosotros como nuestro compañero comprobaremos que hemos podido descifrar los mensajes recibidos respectivamentePara descifrar un archivo que hemos recibido, utilizaremos la opción -d de gpg, seguida del nombre del archivo a descifrar. En este caso, el archivo que hemos recibido de Jose es mensaje_cifrado.gpg.El comando a ejecutar sería:pavlo@debian:~()$ gpg -d mensaje_cifrado.gpggpg: cifrado con clave de 3072 bits RSA, ID 8E63E9C3C10E3D32, creada el 2024-12-12      \"Pablo Martín Hidalgo &lt;pmartinhidalgo19@gmail.com&gt;\"Espero que ganemos el sábadoTras ejecutar el comando, se nos pedirá la frase de paso para desbloquear la clave privada con la que vamos a descifrar el fichero (pues anteriormente fue cifrado con la clave pública asociada a dicha clave privada).Como se puede observar, el contenido del archivo descifrado no está en texto plano, sino que corresponde a un archivo .txt encriptado.pavlo@debian:~()$ cat mensaje_cifrado.gpg ���c���=2         �������42�曄:�1�J;)�\t6�&gt;�),��_�-g�g*���pȆ]8@�x�,K��Ҭ�,��g�W?�m�\"��dA0jb��z�\\����ݑb��a�5mk�6�� ��c��ޘ_=\"�e�G�օb}+�3(A&amp;�T��uG�h��?��/5�;D� ֖B������. ���Al�B�[_]�Tno7��ݯ�M��IT���;BtLn���Xqߵ�&gt;�R-�[[Z�D���-������.C��zu���|���/�ˊ��'5&amp;                                                                                                                                      �2r����&gt;Vq���[ԙ��TK-����N~3Q=�g0C:���XE���U:�`V�~\t�0��˴������E$�j�~}�������2���܍�L״��k���d=-���L1T'�bp����rBjq�B�����ad1:�'s��M2�  �tw��i%�}A#%Xh�Y`��k�,�mt&gt;|~                              �]��ɽVV7b^��KPara visualizarlo correctamente, debemos redirigir la salida del archivo descifrado a un archivo de formato .txt.Para ello, volvemos a ejecutar el comando de descifrado, pero esta vez redirigiendo la salida a un archivo con extensión .txt, como por ejemplo descifrado.txt.El comando a ejecutar sería:pavlo@debian:~()$ gpg -d mensaje_cifrado.gpg &gt; descifrado.txtgpg: cifrado con clave de 3072 bits RSA, ID 8E63E9C3C10E3D32, creada el 2024-12-12      \"Pablo Martín Hidalgo &lt;pmartinhidalgo19@gmail.com&gt;\"Y como vemos el contenido es totalmente visible:pavlo@debian:~()$ cat descifrado.txt Espero que ganemos el sábado4. Por último, enviaremos el documento cifrado a alguien que no estaba en la lista de destinatarios y comprobaremos que este usuario no podrá descifrar este archivoPara este punto hemos pedido ayuda a Andrés Morales, al cual le he enviado el fichero y ha comprobado si podía abrirlo o no. Y como podemos observar obtuvo el siguiente error:madandy@toyota-hilux:~/Descargas$ gpg -d mensaje_encriptado.txt.gpg gpg: cifrado con clave RSA, ID 6CB51A1718E6B9E9gpg: descifrado fallido: No secret keyComo se puede apreciar, el descifrado ha fallado dado que no ha encontrado ninguna clave privada para descifrar dicho fichero.5. Para terminar, indica los comandos necesarios para borrar las claves públicas y privadas que poseesEs importante seguir un orden específico al eliminar un par de claves en GPG para evitar errores. Primero, debemos eliminar la clave privada asociada y, posteriormente, la clave pública.Para eliminar la clave privada, utilizaremos la opción --delete-secret-key de gpg, seguida del nombre asociado al par de claves (el mismo que introdujimos al generarlo). El comando sería:pavlo@debian:~()$ gpg --delete-secret-key \"Pablo Martín Hidalgo\"gpg (GnuPG) 2.2.40; Copyright (C) 2022 g10 Code GmbHThis is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.sec  rsa3072/130D7BAF24114BE7 2024-12-12 Pablo Martín Hidalgo &lt;pmartinhidalgo19@gmail.com&gt;¿Eliminar esta clave del anillo? (s/N) s¡Es una clave secreta! ¿Eliminar realmente? (s/N) sUna vez eliminada la clave privada, procedemos a eliminar la clave pública con la opción –delete-key:pavlo@debian:~()$ gpg --delete-key \"Pablo Martín Hidalgo\"gpg (GnuPG) 2.2.40; Copyright (C) 2022 g10 Code GmbHThis is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.pub  rsa3072/130D7BAF24114BE7 2024-12-12 Pablo Martín Hidalgo &lt;pmartinhidalgo19@gmail.com&gt;¿Eliminar esta clave del anillo? (s/N) sAl completar ambos pasos, el par de claves (tanto público como privado) habrá sido eliminado de nuestro sistema.pavlo@debian:~()$ gpg --list-keysgpg: comprobando base de datos de confianzagpg: no se encuentran claves absolutamente fiables/home/pavlo/.gnupg/pubring.kbx------------------------------pub   rsa3072 2024-12-12 [SC] [caduca: 2026-12-12]      279F1D439CE7DA18300BF21D5DD99C6F8D4E1C65uid        [desconocida] jose antonio Canalo Gonzalez &lt;joseantoniocgonzalez83@gmail.com&gt;sub   rsa3072 2024-12-12 [E] [caduca: 2026-12-12]Tarea 4: Exportar clave a un servidor público de claves PGP1. Genera la clave de revocación de tu clave pública para utilizarla en caso de que haya problemasCuando generamos un par de claves con GPG, el programa crea automáticamente una clave de revocación. Sin embargo, para mostrar el proceso manual, generaremos una nueva clave de revocación.Para generar una clave de revocación, utilizaremos la opción --gen-revoke de gpg, seguida del identificador del par de claves (conocido como fingerprint). Este identificador es una secuencia de 40 dígitos que podemos encontrar al listar nuestras claves públicas con el siguiente comando:pavlo@debian:~()$ gpg --gen-revoke F0BCAC25DBEF1413DA96DFE02F56104F90EDEC18sec  rsa3072/2F56104F90EDEC18 2024-12-12 Pablo Martín Hidalgo &lt;pmartinhidalgo19@gmail.com&gt;¿Crear un certificado de revocación para esta clave? (s/N) sPor favor elija una razón para la revocación:  0 = No se dio ninguna razón  1 = La clave ha sido comprometida  2 = La clave ha sido reemplazada  3 = La clave ya no está en uso  Q = Cancelar(Probablemente quería seleccionar 1 aquí)¿Su decisión? 0Introduzca una descripción opcional; acábela con una línea vacía:&gt; Ejercicios de criptografía&gt; Razón para la revocación: No se dio ninguna razónEjercicios de criptografía¿Es correcto? (s/N) sse fuerza salida con armadura ASCII.-----BEGIN PGP PUBLIC KEY BLOCK-----Comment: This is a revocation certificateiQHRBCABCgA7FiEE8LysJdvvFBPalt/gL1YQT5Dt7BgFAmdbJhkdHQBFamVyY2ljaW9zIGRlIGNyaXB0b2dyYWbDrWEACgkQL1YQT5Dt7Bgkiwv7BLuEp9rUi3hgiYhJhCPyh9FqkD9UJByICZmdVf/wgP9BnKIy0SC9KEEjUF9Fko6N/nDz0EMVAwZ4WtCPflt3xq0ACJUfzGp9llP2iNujpcCbmdlwHDMwhCkvcI+ri4pb0fmZPRhw3BO9Ad4EcDMQ2LFffJ29zbBsWS1RqYZzTGEytjB3m5BaoIq+C5HAnM7dImfKbV5DBdCLsqCcwnwS1zvlHwFzpf9Ap6IhbmpN4Rf4H+ZBL8siVQrUDlOsbybwgBrzxLtLmaq0EZL+kZL7QHizTHaO9bUJd/PxumfiNiuq3wq5MxdUSnXNEg52bDg4AxPYlWm9IU87wAPB6fHFpwfzJh/VKyfZi7tD0CSb1fRN4qxg7abXRAS/4aRAprOaRFtbyvXiAswvD9oIY8LFxUe5P8OmvuzD9X7npsQX+H3ZbxTvJJZ9RVMn1Oxi1AHWiqqn2ae+jw7CPpgzy9C+FFWJTL/ME4vNeZ+y+EdRboRO+tx96Q453+jwo/tlLF7u=Oyi5-----END PGP PUBLIC KEY BLOCK-----Certificado de revocación creado.Por favor consérvelo en un medio que pueda esconder; si alguien consigueacceso a este certificado puede usarlo para inutilizar su clave.Es inteligente imprimir este certificado y guardarlo en otro lugar, porsi acaso su medio resulta imposible de leer. Pero precaución: ¡el sistemade impresión de su máquina podría almacenar los datos y hacerlos accesiblesa otras personas!El certificado de revocación generado por GPG contiene la información necesaria para revocar un par de claves de forma oficial. Este certificado está delimitado por las etiquetas:—–BEGIN PGP PUBLIC KEY BLOCK—– … —–END PGP PUBLIC KEY BLOCK—–2. Exporta tu clave pública al servidor pgp.rediris.esPara compartir nuestra clave pública con otros usuarios, podemos exportarla a un servidor de claves públicas, lo que permite que cualquiera pueda buscarla y utilizarla para cifrar mensajes destinados a nosotros.Para exportar la clave pública, utilizaremos la opción --keyserver para especificar el servidor al cual queremos enviar la clave y --send-key para indicar el identificador (ID) de la clave pública. En este caso, se utilizará el servidor pgp.rediris.es, y el ID será el fingerprint de la clave, que consta de 40 dígitos. También es posible usar únicamente los últimos 8 dígitos del fingerprint. El comando sería:pavlo@debian:~()$ gpg --keyserver pgp.rediris.es --send-key F0BCAC25DBEF1413DA96DFE02F56104F90EDEC18gpg: enviando clave 2F56104F90EDEC18 a hkp://pgp.rediris.esPara confirmar que la clave ha sido subida correctamente, se puede acceder al servidor de claves públicas mediante un navegador web. En este caso, al visitar la página de búsqueda de claves de pgp.rediris.es, es posible introducir un identificador como el nombre o la dirección de correo electrónico en el campo de búsqueda.Por ejemplo, al introducir el correo electrónico en el campo de búsqueda y pulsar “Search for a key”, aparecerán los resultados que coincidan con la búsqueda realizada.Si todo ha funcionado correctamente, debería verse la clave pública entre los resultados, lo que confirma que la subida al servidor de claves públicas se ha completado de manera satisfactoria. Exportar claves públicas a servidores como pgp.rediris.es facilita el intercambio de claves y asegura que otras personas puedan comunicarse de forma segura.3. Borra la clave pública de alguno de tus compañeros de clase e impórtala ahora del servidor público de redirisTal y como hemos visto en uno de los ejercicios anteriores, para eliminar una clave pública de nuestro keyring, utilizaremos la opción --delete-key seguida del nombre asociado a la clave. En este caso, el nombre que debemos introducir es el de Jose.pavlo@debian:~()$ gpg --delete-key \"jose antonio canalo gonzalez\"gpg (GnuPG) 2.2.40; Copyright (C) 2022 g10 Code GmbHThis is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.pub  rsa3072/5DD99C6F8D4E1C65 2024-12-12 jose antonio Canalo Gonzalez &lt;joseantoniocgonzalez83@gmail.com&gt;¿Eliminar esta clave del anillo? (s/N) sY listo, la clave pública de Jose ya se encuentra borrada:pavlo@debian:~()$ gpg --list-keys/home/pavlo/.gnupg/pubring.kbx------------------------------pub   rsa3072 2024-12-12 [SC] [caduca: 2026-12-12]      F0BCAC25DBEF1413DA96DFE02F56104F90EDEC18uid        [  absoluta ] Pablo Martín Hidalgo &lt;pmartinhidalgo19@gmail.com&gt;sub   rsa3072 2024-12-12 [E] [caduca: 2026-12-12]Una vez que la clave pública ha sido totalmente eliminada, es momento de volver a importarla desde el servidor de claves públicas. Para ello, utilizaremos la opción --keyserver para especificar el servidor del que queremos descargar la clave y --recv-keys para indicar el identificador (fingerprint) de la clave pública.En este caso, el servidor a utilizar será pgp.rediris.es, y el ID será el fingerprint de 40 dígitos de la clave de Alejandro. También se pueden usar los últimos 8 dígitos del fingerprint.pavlo@debian:~()$ gpg --keyserver pgp.rediris.es --recv-keys 5D55680Cgpg: clave A93FC51D5D55680C: clave pública \"jose antonio canalo gonzalez &lt;joseantoniocgonzalez83@gmail.com&gt;\" importadagpg: Cantidad total procesada: 1gpg:               importadas: 1Como vemos, la clave pública de Jose ha sido importada de nuevo:pavlo@debian:~()$ gpg --list-keys/home/pavlo/.gnupg/pubring.kbx------------------------------pub   rsa3072 2024-12-12 [SC] [caduca: 2026-12-12]      F0BCAC25DBEF1413DA96DFE02F56104F90EDEC18uid        [  absoluta ] Pablo Martín Hidalgo &lt;pmartinhidalgo19@gmail.com&gt;sub   rsa3072 2024-12-12 [E] [caduca: 2026-12-12]pub   rsa3072 2024-12-12 [SC] [caduca: 2026-12-12]      B93E1746A5B533527796FC9DA93FC51D5D55680Cuid        [desconocida] jose antonio canalo gonzalez &lt;joseantoniocgonzalez83@gmail.com&gt;sub   rsa3072 2024-12-12 [E] [caduca: 2026-12-12]Tarea 5: Cifrado asimétrico con openssl1. Genera un par de claves (pública y privada)Para generar el par de claves utilizando el algoritmo RSA, emplearemos la opción genrsa. Además, configuraremos una frase de paso para proteger la clave privada, utilizando el algoritmo AES128, lo que requiere incluir la opción -aes128. Este par de claves se almacenará en un único archivo con extensión .pem, y para especificar dicho archivo de salida usaremos la opción -out &lt;fichero&gt;. En este caso, el archivo de salida se llamará key.pem. Finalmente, indicaremos el tamaño de la clave, siendo recomendable un mínimo de 2048 bits.pavlo@debian:~()$ sudo openssl genrsa -aes128 -out clave.pem 2048[sudo] contraseña para pavlo: Enter PEM pass phrase:Verifying - Enter PEM pass phrase:Tras habernos preguntado dos veces la frase de paso, el par de claves se habrá generado en un fichero .pem.2. Envía tu clave pública a un compañeroDado que openssl genera tanto la clave privada como la pública en un único archivo, es necesario extraer la clave pública para enviársela al compañero. Esto se debe a que no es seguro compartir el archivo que contiene ambas claves. Para realizar esta extracción, utilizaremos la opción -in &lt;pardeclaves&gt; para especificar el archivo que contiene el par de claves, junto con la opción -pubout para indicar que se extraiga únicamente la clave pública. Además, emplearemos la opción -out &lt;ficherosalida&gt; para guardar la clave pública en un archivo separado con la extensión .public.pem. Por último, indicaremos el algoritmo RSA, que es el que estamos utilizando.En este caso, el archivo del par de claves es clave.pem y el archivo de salida para la clave pública será clave-publica.pem.pavlo@debian:~()$ sudo openssl rsa -in clave.pem -pubout -out clave-publica.pemEnter pass phrase for clave.pem:writing RSA keyNos ha solicitado la frase de paso y justo después ha generado el fichero con la clave pública:pavlo@debian:~()$ cat clave-publica.pem -----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwTaSZx2rgZxL8H0XoU48Orzus0tpPn64xw/ftf0Sk5sh6MMnkVgbdug1Iydxun28rs8L1iULPoGDZUUZARMc6oa4CuW6gu6gsfvul4bktpSps9NjJmHA0Vd2Gehp7PMncxzXFPokwwinetSZi85J9uL2/RSJes2AxxRVxBIonOurpuBxWuaAB50ptDL2v6h0B3+A/1dtOdsSY1KmSuTqQFKVYry3sYKvPOJMy4JX78GSCzy5E/SPwnv3f6oD22Ual7MqIcDgNZsQ6tHjCZXPz/4VRA9SAkQ5yTIcSkb5IT/NxxkuiItHp1rwEnkfbxP2tymaUj5udVp5uQ6YT1/SsQIDAQAB-----END PUBLIC KEY-----Ahora, Jose y yo nos pasamos nuestra clave pública:3. Utilizando la clave pública cifra un fichero de texto y envíalo a tu compañeroLo primero que haremos será generar un fichero de texto con el contenido que deseemos:pavlo@debian:~()$ echo \"Hoy pierde el Betis\" &gt; archivo.txtTras la extracción de la clave pública, podremos proceder a cifrar un archivo utilizando la clave pública del destinatario. Esto se logra mediante el uso de las opciones de openssl. Específicamente:  La opción -encrypt indica que deseamos cifrar el archivo.  La opción -in &lt;fichero&gt; especifica el archivo de entrada que se desea cifrar.  La opción -out &lt;ficherosalida&gt; define el archivo de salida que contendrá los datos cifrados, con una extensión habitual como .enc.  La opción -inkey &lt;clavepublica&gt; especifica la clave pública que se usará para el cifrado.  La opción -pubin se utiliza para señalar que estamos trabajando con una clave pública.  Finalmente, el comando pkeyutl se emplea para realizar operaciones de firma, verificación, cifrado o descifrado con RSA.En este caso, el archivo de entrada será archivo.txt, el archivo de salida será mensaje_encriptado.enc, y la clave pública utilizada será la de Jose, contenida en clave_publica.pem.pavlo@debian:~()$ openssl pkeyutl -encrypt -in archivo.txt -out mensaje_encriptado.enc -inkey clave_publica.pem -pubinComo vemos, el mensaje encriptado utiliza carácteres no reconocidos:pavlo@debian:~()$ cat mensaje_encriptado.enc ��h�u*�3�ݔL��;\"v��T������_f.VH4�C��y!                                     �ei�0dKs   �����T������'&gt;�����Dd�F��-�^}�\t��t�p���j@ݓ�Dg�P�a3N�bE��I�Ҝ��U����cL�@�FKa�2e��z[?3�l���4De nuevo, yo le paso mi mensaje cifrado para que lo averigüe y yo me descargo el suyo:4. Tu compañero te ha mandado un fichero cifrado, muestra el proceso para el descifradoPara descifrar un archivo previamente cifrado, utilizamos la herramienta openssl con las siguientes opciones:  La opción -decrypt indica que queremos realizar la operación de descifrado.  La opción -in &lt;fichero&gt; especifica el archivo cifrado que deseamos descifrar.  La opción -out &lt;ficherosalida&gt; define el archivo donde se guardará el contenido descifrado.  La opción -inkey &lt;claveprivada&gt; señala la clave privada que se utilizará para descifrar el archivo.  Al igual que en el cifrado, la opción pkeyutl se usa para realizar operaciones de firma, verificación, cifrado o descifrado con el algoritmo RSA.En este caso, el archivo de entrada será mensajenuevo_cifrado.enc, el archivo de salida será documento.txt, y la clave privada utilizada será clave.pem, la cual generamos previamente.pavlo@debian:~()$ sudo openssl pkeyutl -decrypt -in mensajenuevo_cifrado.enc -out documento.txt -inkey clave.pemY como vemos, podemos visualizar el contenido:pavlo@debian:~()$ cat documento.txt ojala eliminen al betis"
  },
  
  {
    "title": "Escenario en OpenStack",
    "url": "/posts/openstack/",
    "categories": "Servicios, Cloud",
    "tags": "Cloud",
    "date": "2024-12-11 18:15:00 +0100",
    





    
    "snippet": "Práctica (1 / 2): Escenario en OpenStackPara nombrar las máquinas se van a utilizar los siguientes nombres: luffy, zoro, nami, sanji. Estos nombres pertenecen la serie manga One Piece.Además el dom...",
    "content": "Práctica (1 / 2): Escenario en OpenStackPara nombrar las máquinas se van a utilizar los siguientes nombres: luffy, zoro, nami, sanji. Estos nombres pertenecen la serie manga One Piece.Además el dominio será un subdominio de la forma tunombre.gonzalonazareno.org. De esta forma tendremos:  Máquina 1: Instancia en OpenStack con Debian 12 Bookworm que se llama luffy.tunombre.gonzalonazareno.org.  Máquina 2: Instancia en OpenStack con Rocky Linux 9 que se llama zoro.tunombre.gonzalonazareno.org.  Máquina 3: Contenedor LXC con Ubuntu 22.04 que se llama nami.tunombre.gonzalonazareno.org.  Máquina 4: Contenedor LXC con Ubuntu 22.04 que se llama sanji.tunombre.gonzalonazareno.org.Todas las operaciones que realices sobre recursos de OpenStack lo tienes que hacer usando OSC.Creación de la infraestructura de red  Crea un nuevo router llamado RouterPractica conectado a la red externa.Para crear el router ejecutamos el siguiente comando:(os) pavlo@debian:~/OpenStack()$ openstack router create RouterPractica+---------------------------+--------------------------------------+| Field                     | Value                                |+---------------------------+--------------------------------------+| admin_state_up            | UP                                   || availability_zone_hints   |                                      || availability_zones        |                                      || created_at                | 2024-12-11T17:32:26Z                 || description               |                                      || enable_default_route_bfd  | False                                || enable_default_route_ecmp | False                                || enable_ndp_proxy          | None                                 || external_gateway_info     | null                                 || external_gateways         | []                                   || flavor_id                 | None                                 || id                        | c94e22f0-5551-4842-9628-a9d3929b5539 || name                      | RouterPractica                       || project_id                | 07df99f775d343a58e702b5c99adcbad     || revision_number           | 1                                    || routes                    |                                      || status                    | ACTIVE                               || tags                      |                                      || tenant_id                 | 07df99f775d343a58e702b5c99adcbad     || updated_at                | 2024-12-11T17:32:26Z                 |+---------------------------+--------------------------------------+Luego, lo añadimos a la red pública que por lo general suele ser public, aunque en este caso es ext-net:(os) pavlo@debian:~/OpenStack()$ openstack router set RouterPractica --external-gateway ext-net      Crea una red interna que se llame Red Intra de tu_usuario, con las siguientes características:                  Está conectada al router que has creado en el punto anterior.                    Direccionamiento: 10.0.200.0/24                    Con DHCP y DNS (172.22.0.1).                    La puerta de enlace de los dispositivos conectados a esta red será el 10.0.200.1.            Para este paso debemos crear una red:(os) pavlo@debian:~/OpenStack()$ openstack network create red-intra-pablo+---------------------------+--------------------------------------+| Field                     | Value                                |+---------------------------+--------------------------------------+| admin_state_up            | UP                                   || availability_zone_hints   |                                      || availability_zones        |                                      || created_at                | 2024-12-11T17:33:53Z                 || description               |                                      || dns_domain                | None                                 || id                        | 260d2b52-38e8-449f-a368-a68824d2474f || ipv4_address_scope        | None                                 || ipv6_address_scope        | None                                 || is_default                | False                                || is_vlan_transparent       | None                                 || mtu                       | 1442                                 || name                      | red-intra-pablo                      || port_security_enabled     | True                                 || project_id                | 07df99f775d343a58e702b5c99adcbad     || provider:network_type     | None                                 || provider:physical_network | None                                 || provider:segmentation_id  | None                                 || qos_policy_id             | None                                 || revision_number           | 1                                    || router:external           | Internal                             || segments                  | None                                 || shared                    | False                                || status                    | ACTIVE                               || subnets                   |                                      || tags                      |                                      || updated_at                | 2024-12-11T17:33:53Z                 |+---------------------------+--------------------------------------+Luego, crear la subred con las especificaciones:(os) pavlo@debian:~/OpenStack()$ openstack subnet create red-intra-pablo-subnet \\&gt; --network red-intra-pablo \\&gt; --subnet-range 10.0.200.0/24 \\&gt; --dhcp \\&gt; --gateway 10.0.200.1 \\&gt; --dns-nameserver 172.22.0.1+----------------------+--------------------------------------+| Field                | Value                                |+----------------------+--------------------------------------+| allocation_pools     | 10.0.200.2-10.0.200.254              || cidr                 | 10.0.200.0/24                        || created_at           | 2024-12-11T17:35:40Z                 || description          |                                      || dns_nameservers      | 172.22.0.1                           || dns_publish_fixed_ip | None                                 || enable_dhcp          | True                                 || gateway_ip           | 10.0.200.1                           || host_routes          |                                      || id                   | 7ef74cd9-63bf-4b2e-8479-69250a4a087b || ip_version           | 4                                    || ipv6_address_mode    | None                                 || ipv6_ra_mode         | None                                 || name                 | red-intra-pablo-subnet               || network_id           | 260d2b52-38e8-449f-a368-a68824d2474f || project_id           | 07df99f775d343a58e702b5c99adcbad     || revision_number      | 0                                    || segment_id           | None                                 || service_types        |                                      || subnetpool_id        | None                                 || tags                 |                                      || updated_at           | 2024-12-11T17:35:40Z                 |+----------------------+--------------------------------------+Por último añadimos la subnet creada en el paso anterior al router creado al principio:(os) pavlo@debian:~/OpenStack()$ openstack router add subnet RouterPractica red-intra-pablo-subnet      Crea una red interna que se llame Red DMZ de tu_usuario, con las siguientes características:                  Direccionamiento: 172.16.0.0/16                    Sin DHCP.                    Deshabilitamos la puerta de enlace. Esto es para que cloud-init no configure la puerta de enlace en las instancias conectada a esta red.                    La puerta de enlace de los dispositivos conectados a esta red será el 172.16.0.1.            Para crear esta red hacemos lo mismo que antes:(os) pavlo@debian:~/OpenStack()$ openstack network create red-dmz-pablo+---------------------------+--------------------------------------+| Field                     | Value                                |+---------------------------+--------------------------------------+| admin_state_up            | UP                                   || availability_zone_hints   |                                      || availability_zones        |                                      || created_at                | 2024-12-11T17:41:36Z                 || description               |                                      || dns_domain                | None                                 || id                        | b6ae55f9-e6fb-4509-bd3b-fd627a3da1d8 || ipv4_address_scope        | None                                 || ipv6_address_scope        | None                                 || is_default                | False                                || is_vlan_transparent       | None                                 || mtu                       | 1442                                 || name                      | red-dmz-pablo                        || port_security_enabled     | True                                 || project_id                | 07df99f775d343a58e702b5c99adcbad     || provider:network_type     | None                                 || provider:physical_network | None                                 || provider:segmentation_id  | None                                 || qos_policy_id             | None                                 || revision_number           | 1                                    || router:external           | Internal                             || segments                  | None                                 || shared                    | False                                || status                    | ACTIVE                               || subnets                   |                                      || tags                      |                                      || updated_at                | 2024-12-11T17:41:36Z                 |+---------------------------+--------------------------------------+Luego creamos la subnet indicando que no queremos dhcp ni puerta de enlace:(os) pavlo@debian:~/OpenStack()$ openstack subnet create red-dmz-pablo-subnet \\&gt; --network red-dmz-pablo \\&gt; --subnet-range 172.16.0.0/16 \\&gt; --no-dhcp \\&gt; --gateway none+----------------------+--------------------------------------+| Field                | Value                                |+----------------------+--------------------------------------+| allocation_pools     | 172.16.0.1-172.16.255.254            || cidr                 | 172.16.0.0/16                        || created_at           | 2024-12-11T17:44:05Z                 || description          |                                      || dns_nameservers      |                                      || dns_publish_fixed_ip | None                                 || enable_dhcp          | False                                || gateway_ip           | None                                 || host_routes          |                                      || id                   | 450496f9-646a-42a4-9a8e-b07b5b3a992d || ip_version           | 4                                    || ipv6_address_mode    | None                                 || ipv6_ra_mode         | None                                 || name                 | red-dmz-pablo-subnet                 || network_id           | b6ae55f9-e6fb-4509-bd3b-fd627a3da1d8 || project_id           | 07df99f775d343a58e702b5c99adcbad     || revision_number      | 0                                    || segment_id           | None                                 || service_types        |                                      || subnetpool_id        | None                                 || tags                 |                                      || updated_at           | 2024-12-11T17:44:05Z                 |+----------------------+--------------------------------------+Aunque no configuramos la puerta de enlace en la red (para evitar que cloud-init lo haga automáticamente), las instancias se pueden configurar manualmente si es necesario.La dirección 172.16.0.1 será la puerta de enlace predeterminada que los dispositivos pueden usar.Instalación de las instancias de OpenStackConfiguración de las instanciasLas dos instancias que vamos a crear se van a configurar con cloud-init de la siguiente manera:      Deben actualizar los paquetes de la distribución de la instancia.        El dominio utilizado será del tipo tunombre.gonzalonazareno.org. Por lo tanto en la configuración con cloud-init habrá que indicar el hostname y el FQDN.        Se crearán dos usuarios:                  Un usuario sin privilegios. Se puede llamar como quieras (pero el nombre será el mismo en todas las máquinas) y accederás a las máquinas usando tu clave ssh privada.                    Un usuario profesor, que puede utilizar sudo sin contraseña. Copia de las claves públicas de todos los profesores en las instancias para que puedan acceder con el usuario profesor.                  Cambia la contraseña al usuario root.  Bueno pues para ello debemos crear el fichero cloud-init-luffy.yaml en donde añadiremos las configuraciones que se pide:#cloud-configpackage_update: truepackage_upgrade: truehostname: luffyfqdn: luffy.pablo.gonzalonazareno.orgusers:  - name: pablo    shell: /bin/bash    sudo: ['ALL=(ALL) NOPASSWD:ALL']    ssh_authorized_keys:      - \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQClFcnIhYd1oaEpvGi/f4psQc4+DaAZvSNIxVRRJHtRoJui8wbJybi3Om8yTOflgEcmBaUrJLkfmzmWqVq1j6MpESq72p7J2hdq2lXnvzdt3huYv5evFwyd0p/r72RfpVZzr3ILi/BS//SJqfVKlDEVbZRaOE5MU2XuElmFFY4EO7NiiZAkbatVqUOT8H/nrfXcad0mjZVxroVqHhsHV+06rxiB0xifG0xZv204Qj4zRura8uqZlEVAAwU+NO/SIGdRwpLY7n7xbQGe1DbjHgPUeVPjJX6HpMK41a43eGj4XYdYtZBLugaU8Mq1y6Kl3tE6cvYkQ9WFTYTLLNy3bvNRZpP2p6qAy5qn03ZLFICiXBNXPmrl5+KVrKaSipNaPHkmInvczbYJjXpfyVBsfEabt+0Y1629M+eEKkkl+iZmVr2ySDSS1gHxMC7zlJRaUhG27o26agpNPYPHH3mVXVjqdGg0ryH0YHZk1V8+Gt1Z9hZ7UYWE1UX8DCgFfecqdX0= pavlo@debian\"  - name: profesor    shell: /bin/bash    sudo: ['ALL=(ALL) NOPASSWD:ALL']    ssh_authorized_keys:      - \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCmjoVIoZCx4QFXvljqozXGqxxlSvO7V2aizqyPgMfGqnyl0J9YXo6zrcWYwyWMnMdRdwYZgHqfiiFCUn2QDm6ZuzC4Lcx0K3ZwO2lgL4XaATykVLneHR1ib6RNroFcClN69cxWsdwQW6dpjpiBDXf8m6/qxVP3EHwUTsP8XaOV7WkcCAqfYAMvpWLISqYme6e+6ZGJUIPkDTxavu5JTagDLwY+py1WB53eoDWsG99gmvyit2O1Eo+jRWN+mgRHIxJTrFtLS6o4iWeshPZ6LvCZ/Pum12Oj4B4bjGSHzrKjHZgTwhVJ/LDq3v71/PP4zaI3gVB9ZalemSxqomgbTlnT jose@debian\"      - \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDf9lnBH2nCT2ezpDZnqSBeDuSsVGGFD1Kzqa4KyIVkzkrD7pNHHkkpSuO4isKcCsUcopYOcA38QtG7wB0v/qn8Jsq731N8bjaKOdQN25vqLjwVj8DpYtvGc+ZA0uaChe7TS+QBzlMC9ypwj4wf15Q/z3v/ip4FF2cORT0cQC04cNRQDgUg4p1rlOs8+ma7OPh3P3UvzlPfLhi2H1yl+/mo4XLOcAMNr/jiZCwYxom6OEOYVBNk8MZX/Zn+qRi71D0RPiKg27AcXSD/FPWdQW9hBH1Zq5xGicUFS4C9yXvHKru7cMmmxV2G80p/ArRscKWq92UT5jIJQpccmHxsxdIi6o25LhcxH1dOnZy6kHcJ2yP24CnBHK5Y3SsovCD0Th6MN1VlTySbl8Ar0ypmY+GYO+oVd4bM3ioHzL0AMqYnS29m0UtEDvFEUUoSkOoLK4uSlcvej+OIVp7X5G7oZ56nZZf+qHEgodv++a6vPmhH2ZSgoOj1sE39DK7InuKSqCE= rafa@eco\"      - \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDASDwvkY5SbIgM+/j14mNQluPV+/HGcM3ZgXrYDWt7zhQKq8KAXqJLs1vw1HcRv5PRV071caZQxV2ssfrNqIDofjSzWM1I1JkVIqIj4NCOsRFsQQFN8HwfkE9ic/X6vRaV+NfkEF+t3VmX2YgBd02ZbmGt53qjDaGMQRS/qxw3MPS+ynf2Fj8ZibT6DZeWnyjEGhFcyrggFWiPDqw77MNaiDr+31SO0TaP1WeIWFMrSwPVMVG1zvSxAQ9L13SQ5XzwK0Xs2A8kBPiZmPuUFRqYlBWeffhUnRPSg4TdOsWqJjEwFb5OwpQmTDCT5z0MSFCNVLV5GGwvvqCrw5jd1Xfdswdqazc8mCaIPIrCmhsiwz7uZvQDYr1HDrKxJ1L8LLo3usp4FM5cCCM5jptK+XffhmIyJSkMrcg6tYawBeNuAiY3dwPRIyKeV1Ku3UUctkN+kbuOpMQ4nSvAK0DyhUiTakc8qMJDNLD8oHhSEp49G2bzsLwFOmaEgb8falVMLyk= javji@Javier\"  - name: root    passwd: \"root\"final_message: \"Instancia configurada correctamente.\"Este fichero está destinado a la configuración de la instancia luffy.A continuación, crearé el archivo cloud-init-zoro.yaml para la posterior creación de la instancia zoro.#cloud-configpackage_update: truepackage_upgrade: truehostname: zorofqdn: zoro.pablo.gonzalonazareno.orgusers:  - name: pablo    gecos: Usuario sin privilegios    groups: []    shell: /bin/bash    sudo: ['ALL=(ALL) NOPASSWD:ALL']    ssh_authorized_keys:      - \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQClFcnIhYd1oaEpvGi/f4psQc4+DaAZvSNIxVRRJHtRoJui8wbJybi3Om8yTOflgEcmBaUrJLkfmzmWqVq1j6MpESq72p7J2hdq2lXnvzdt3huYv5evFwyd0p/r72RfpVZzr3ILi/BS//SJqfVKlDEVbZRaOE5MU2XuElmFFY4EO7NiiZAkbatVqUOT8H/nrfXcad0mjZVxroVqHhsHV+06rxiB0xifG0xZv204Qj4zRura8uqZlEVAAwU+NO/SIGdRwpLY7n7xbQGe1DbjHgPUeVPjJX6HpMK41a43eGj4XYdYtZBLugaU8Mq1y6Kl3tE6cvYkQ9WFTYTLLNy3bvNRZpP2p6qAy5qn03ZLFICiXBNXPmrl5+KVrKaSipNaPHkmInvczbYJjXpfyVBsfEabt+0Y1629M+eEKkkl+iZmVr2ySDSS1gHxMC7zlJRaUhG27o26agpNPYPHH3mVXVjqdGg0ryH0YHZk1V8+Gt1Z9hZ7UYWE1UX8DCgFfecqdX0= pavlo@debian\"  - name: profesor    gecos: Usuario Profesor    groups: sudo    shell: /bin/bash    sudo: ['ALL=(ALL) NOPASSWD:ALL']    ssh_authorized_keys:      - \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCmjoVIoZCx4QFXvljqozXGqxxlSvO7V2aizqyPgMfGqnyl0J9YXo6zrcWYwyWMnMdRdwYZgHqfiiFCUn2QDm6ZuzC4Lcx0K3ZwO2lgL4XaATykVLneHR1ib6RNroFcClN69cxWsdwQW6dpjpiBDXf8m6/qxVP3EHwUTsP8XaOV7WkcCAqfYAMvpWLISqYme6e+6ZGJUIPkDTxavu5JTagDLwY+py1WB53eoDWsG99gmvyit2O1Eo+jRWN+mgRHIxJTrFtLS6o4iWeshPZ6LvCZ/Pum12Oj4B4bjGSHzrKjHZgTwhVJ/LDq3v71/PP4zaI3gVB9ZalemSxqomgbTlnT jose@debian\"      - \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDf9lnBH2nCT2ezpDZnqSBeDuSsVGGFD1Kzqa4KyIVkzkrD7pNHHkkpSuO4isKcCsUcopYOcA38QtG7wB0v/qn8Jsq731N8bjaKOdQN25vqLjwVj8DpYtvGc+ZA0uaChe7TS+QBzlMC9ypwj4wf15Q/z3v/ip4FF2cORT0cQC04cNRQDgUg4p1rlOs8+ma7OPh3P3UvzlPfLhi2H1yl+/mo4XLOcAMNr/jiZCwYxom6OEOYVBNk8MZX/Zn+qRi71D0RPiKg27AcXSD/FPWdQW9hBH1Zq5xGicUFS4C9yXvHKru7cMmmxV2G80p/ArRscKWq92UT5jIJQpccmHxsxdIi6o25LhcxH1dOnZy6kHcJ2yP24CnBHK5Y3SsovCD0Th6MN1VlTySbl8Ar0ypmY+GYO+oVd4bM3ioHzL0AMqYnS29m0UtEDvFEUUoSkOoLK4uSlcvej+OIVp7X5G7oZ56nZZf+qHEgodv++a6vPmhH2ZSgoOj1sE39DK7InuKSqCE= rafa@eco\"      - \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDASDwvkY5SbIgM+/j14mNQluPV+/HGcM3ZgXrYDWt7zhQKq8KAXqJLs1vw1HcRv5PRV071caZQxV2ssfrNqIDofjSzWM1I1JkVIqIj4NCOsRFsQQFN8HwfkE9ic/X6vRaV+NfkEF+t3VmX2YgBd02ZbmGt53qjDaGMQRS/qxw3MPS+ynf2Fj8ZibT6DZeWnyjEGhFcyrggFWiPDqw77MNaiDr+31SO0TaP1WeIWFMrSwPVMVG1zvSxAQ9L13SQ5XzwK0Xs2A8kBPiZmPuUFRqYlBWeffhUnRPSg4TdOsWqJjEwFb5OwpQmTDCT5z0MSFCNVLV5GGwvvqCrw5jd1Xfdswdqazc8mCaIPIrCmhsiwz7uZvQDYr1HDrKxJ1L8LLo3usp4FM5cCCM5jptK+XffhmIyJSkMrcg6tYawBeNuAiY3dwPRIyKeV1Ku3UUctkN+kbuOpMQ4nSvAK0DyhUiTakc8qMJDNLD8oHhSEp49G2bzsLwFOmaEgb8falVMLyk= javji@Javier\"chpasswd:  list: |    root:root  expire: FalseCreación de las instanciasmáquina1 (luffy)      Crea una instancia sobre un volumen de 15Gb (el volumen se crea durante la creación de la instancia), usando una imagen de Debian 12 Bookworm. Elige el sabor vol.medium. Y configuralá con cloud-init como se ha indicado anteriormente.        Está instancia estará conectada a las dos redes. Recuerda que en la red Red DMZ debe tomar la dirección 172.16.0.1 (puerta de enlace las máquinas conectadas a esta red). Asigna a la instancia una IP flotante.        Deshabilita la seguridad de los puertos en las dos interfaces de red para que funcione de manera adecuada el NAT.        Configura de forma permanente la regla SNAT para que las máquinas de la Red DMZ tengan acceso a internet.  En primer lugar debemos crear la instancia:(os) pavlo@debian:~/OpenStack()$ openstack server create luffy \\&gt; --flavor vol.medium \\&gt; --image \"Debian 12 Bookworm\" \\&gt; --network red-intra-pablo \\&gt; --network red-dmz-pablo \\&gt; --user-data cloud-init-luffy.yaml \\&gt; --boot-from-volume 15 \\&gt; --security-group defaultLuego, le asignamos una IP flotante, para ello:(os) pavlo@debian:~/OpenStack()$ openstack server add floating ip luffy 172.22.200.100Comprobamos que se hayan añadido las interfaces correctamente:(os) pavlo@debian:~/OpenStack()$ openstack server list+--------------------------------------+-------+--------+--------------------------------------------------------------------------+--------------------------+------------+| ID                                   | Name  | Status | Networks                                                                 | Image                    | Flavor     |+--------------------------------------+-------+--------+--------------------------------------------------------------------------+--------------------------+------------+| 91e29177-4a4f-4529-8594-4f867d2dd6bd | luffy | ACTIVE | red-dmz-pablo=172.16.3.142; red-intra-pablo=10.0.200.181, 172.22.200.100 | N/A (booted from volume) | vol.medium |+--------------------------------------+-------+--------+--------------------------------------------------------------------------+--------------------------+------------+Ahora debemos deshabilitar la seguridad de los puertos en las dos interfaces de red, para ello primero obtenemos las IDs de los puertos:(os) pavlo@debian:~/OpenStack()$ openstack port list --server luffy+--------------------------------------+------+-------------------+-----------------------------------------------------------------------------+--------+| ID                                   | Name | MAC Address       | Fixed IP Addresses                                                          | Status |+--------------------------------------+------+-------------------+-----------------------------------------------------------------------------+--------+| 1505f6e0-7c0f-47d3-b865-1a5420c69246 |      | fa:16:3e:d9:cb:6a | ip_address='172.16.3.142', subnet_id='450496f9-646a-42a4-9a8e-b07b5b3a992d' | ACTIVE || 3168307f-1878-4306-a1c3-81256a9dd85a |      | fa:16:3e:ff:1e:6d | ip_address='10.0.200.181', subnet_id='7ef74cd9-63bf-4b2e-8479-69250a4a087b' | ACTIVE |+--------------------------------------+------+-------------------+-----------------------------------------------------------------------------+--------+Y una vez sabemos las IDs ya podemos deshabilitarlos:(os) pavlo@debian:~/OpenStack()$ openstack port set 1505f6e0-7c0f-47d3-b865-1a5420c69246 --no-security-group --disable-port-security(os) pavlo@debian:~/OpenStack()$ openstack port set 3168307f-1878-4306-a1c3-81256a9dd85a --no-security-group --disable-port-securityAntes de aceder al router (luffy) y realizar el SNAT voy a añadir en el ~/.ssh/config la máquina para poder conectarme de forma más sencilla:Host luffy  HostName 172.22.200.100  User pablo  ForwardAgent yesDe forma que ya puedo acceder a la instancia:(os) pavlo@debian:~/OpenStack()$ ssh luffy Linux luffy 6.1.0-28-amd64 #1 SMP PREEMPT_DYNAMIC Debian 6.1.119-1 (2024-11-22) x86_64The programs included with the Debian GNU/Linux system are free software;the exact distribution terms for each program are described in theindividual files in /usr/share/doc/*/copyright.Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extentpermitted by applicable law.Last login: Wed Dec 11 22:48:14 2024 from 172.29.0.34pablo@luffy:~$Una vez accedido a luffy habilitamos el bit de forwarding en el fichero /etc/sysctl.conf, en donde descomentamos la siguiente línea:net.ipv4.ip_forward=1Aplicamos los cambios:pablo@luffy:~$ sudo sysctl -pnet.ipv4.ip_forward = 1Ahora debemos configurar la reglas SNAT con iptables, pero antes miramos las direcciones IP de las interfaces:pablo@luffy:~$ ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever    inet6 ::1/128 scope host noprefixroute        valid_lft forever preferred_lft forever2: ens3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1442 qdisc fq_codel state UP group default qlen 1000    link/ether fa:16:3e:8c:07:52 brd ff:ff:ff:ff:ff:ff    altname enp0s3    inet 10.0.200.231/24 metric 100 brd 10.0.200.255 scope global dynamic ens3       valid_lft 42718sec preferred_lft 42718sec    inet6 fe80::f816:3eff:fe8c:752/64 scope link        valid_lft forever preferred_lft forever3: ens4: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1442 qdisc fq_codel state UP group default qlen 1000    link/ether fa:16:3e:67:5a:49 brd ff:ff:ff:ff:ff:ff    altname enp0s4    inet 172.16.0.16/16 brd 172.16.255.255 scope global ens4       valid_lft forever preferred_lft forever    inet6 fe80::f816:3eff:fe67:5a49/64 scope link        valid_lft forever preferred_lft foreverEn base a esta configuración de interfaces de red:  ens3: Interfaz conectada a la red interna (red-intra-pablo, 10.0.200.0/24).  ens4: Interfaz conectada a la red DMZ (red-dmz-pablo, 172.16.0.0/16).Dado esto, necesitamos configurar las reglas SNAT para que el tráfico desde Red DMZ pueda salir a Internet a través de ens3. Para ello:sudo iptables -t nat -A POSTROUTING -o ens3 -s 172.16.0.0/16 -j MASQUERADEDe forma que quede así:pablo@luffy:~$ sudo iptables -t nat -L -vChain PREROUTING (policy ACCEPT 0 packets, 0 bytes) pkts bytes target     prot opt in     out     source               destination         Chain INPUT (policy ACCEPT 0 packets, 0 bytes) pkts bytes target     prot opt in     out     source               destination         Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes) pkts bytes target     prot opt in     out     source               destination         Chain POSTROUTING (policy ACCEPT 0 packets, 0 bytes) pkts bytes target     prot opt in     out     source               destination             0     0 MASQUERADE  all  --  any    ens3    172.16.0.0/16        anywherePara hacer las reglas persistentes instalamos el siguiente paquete:sudo apt install iptables-persistentEn la misma instalación si detecta reglas existentes las guarda automáticamente, aunque si añadimos otras reglas debemos hacerlo manualmente.Con esto, ya habríamos terminado la instalación y configuración al completo del router luffy.maquina2 (zoro)      Crea un volumen de 15Gb con la imagen Rocky Linux 9.        Crea la instancia a partir de este volumen. Elige el sabor vol.medium. Y configúrala con cloud-init como se ha indicado anteriormente.        En un primer momento, para que la instancia se configure mediante cloud-init conecta esta instancia a un red con DHCP.        Posteriormente, desconecta la interfaz de red de esa red y conéctala a la red Red DMZ a la dirección 172.16.0.200.        Recuerda, que esa configuración no se hará de forma automática por lo que deberas, de forma manual, configurar la red en esta máquina. recuerda que Rocky Linux tiene instalado por defecto NetwokManager.        Deshabilita la seguridad de los puertos en la interfaz de red para que funcione de manera adecuada el NAT.        Comprueba que tiene acceso a internet.  Empezamos creando el volumen a partir de la imagen:(os) pavlo@debian:~/OpenStack()$ openstack volume create --size 15 --image \"Rocky Linux 9\" volumen-zoro+---------------------+------------------------------------------------------------------+| Field               | Value                                                            |+---------------------+------------------------------------------------------------------+| attachments         | []                                                               || availability_zone   | nova                                                             || bootable            | false                                                            || consistencygroup_id | None                                                             || created_at          | 2024-12-12T07:44:39.479661                                       || description         | None                                                             || encrypted           | False                                                            || id                  | 786b9400-013c-4bf3-9986-1896891628bf                             || multiattach         | False                                                            || name                | volumen-zoro                                                     || properties          |                                                                  || replication_status  | None                                                             || size                | 15                                                               || snapshot_id         | None                                                             || source_volid        | None                                                             || status              | creating                                                         || type                | lvmdriver-1                                                      || updated_at          | None                                                             || user_id             | a74499e28f7622936621adb74c2b02fe4a18a1f6964a32bdbb23af09b776065f |+---------------------+------------------------------------------------------------------+Seguidamente creamos la instancia a partir del volumen, conectándola en un principio a una red con DHCP como red-intra-pablo.(os) pavlo@debian:~/OpenStack()$ openstack server create zoro \\    --flavor vol.medium \\    --volume volumen-zoro \\    --network red-intra-pablo \\    --user-data cloud-init-zoro.yaml \\    --security-group defaultComprobamos que se haya creado correctamente:(os) pavlo@debian:~/OpenStack()$ openstack server list+--------------------------------------+-------+--------+-------------------------------------------------------------------------+--------------------------+------------+| ID                                   | Name  | Status | Networks                                                                | Image                    | Flavor     |+--------------------------------------+-------+--------+-------------------------------------------------------------------------+--------------------------+------------+| 82692c6d-9d36-4bdd-86b6-46e90bea1892 | zoro  | ACTIVE | red-intra-pablo=10.0.200.132                                            | N/A (booted from volume) | vol.medium || 9c9e8c12-7712-404e-aa3b-2e2bf566ca0c | luffy | ACTIVE | red-dmz-pablo=172.16.0.16; red-intra-pablo=10.0.200.231, 172.22.200.100 | N/A (booted from volume) | vol.medium |+--------------------------------------+-------+--------+-------------------------------------------------------------------------+--------------------------+------------+Ya que se ha creado la instancia y el cloud-init se ha configurado correctamente, añadimos en el fichero ~/.ssh/config la nueva configuración temporal:Host luffy  HostName 172.22.200.100  User pablo  ForwardAgent yesHost zoro  HostName 10.0.200.244  User pablo  ForwardAgent yes  ProxyJump luffyAdemás, añadimos la nueva interfaz que estará conectada a la Red DMZ con la dirección 172.16.0.200, la que posteriormente vamos a configurar manualmente:(os) pavlo@debian:~/OpenStack()$ openstack server add port zoro \\&gt; $(openstack port create --network red-dmz-pablo --fixed-ip subnet=red-dmz-pablo-subnet,ip-address=172.16.0.200 puerto-zoro -f value -c id)Accedemos a la instancia:(os) pavlo@debian:~/OpenStack()$ ssh zoro The authenticity of host '10.0.200.244 (&lt;no hostip for proxy command&gt;)' can't be established.ED25519 key fingerprint is SHA256:JrbuXBRRZ4JoLGdRCCiKNThDEKWqINQtX2NVLKP7Gvo.This host key is known by the following other names/addresses:    ~/.ssh/known_hosts:421: [hashed name]Are you sure you want to continue connecting (yes/no/[fingerprint])? yesWarning: Permanently added '10.0.200.244' (ED25519) to the list of known hosts.Last login: Thu Dec 12 07:52:34 2024 from 10.0.200.231Y hacemos algunas comprobaciones:[pablo@zoro ~]$ hostname -fzoro.pablo.gonzalonazareno.org[pablo@zoro ~]$ ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever    inet6 ::1/128 scope host        valid_lft forever preferred_lft forever2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1442 qdisc fq_codel state UP group default qlen 1000    link/ether fa:16:3e:78:8b:9e brd ff:ff:ff:ff:ff:ff    altname enp0s3    altname ens33: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1442 qdisc fq_codel state UP group default qlen 1000    link/ether fa:16:3e:87:ca:cd brd ff:ff:ff:ff:ff:ff    altname enp0s7    altname ens7    inet 10.0.200.244/24 brd 10.0.200.255 scope global dynamic noprefixroute eth1       valid_lft 43120sec preferred_lft 43120sec    inet6 fe80::7f34:f482:b58c:edcc/64 scope link noprefixroute        valid_lft forever preferred_lft foreverComo vemos la interfaz eth0 está sin direccionamiento, por lo que vamos a añadir la IP para luego poder eliminar la red-intra-pablo.Para ello, creamos el fichero /etc/NetworkManager/system-connections/dmz.nmconnection con la siguiente configuración:[connection]id=dmztype=ethernetinterface-name=eth0[ipv4]method=manualaddresses=172.16.0.200/16gateway=172.16.0.16dns=8.8.8.8;1.1.1.1[ipv6]method=ignoreSeguidamente reiniciamos los servicios:[pablo@zoro ~]$ sudo nmcli connection reload[pablo@zoro ~]$ sudo systemctl restart NetworkManager[pablo@zoro ~]$ sudo nmcli connection up dmzConnection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/4)Y ya tenemos dirección IP:[pablo@zoro ~]$ ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever    inet6 ::1/128 scope host        valid_lft forever preferred_lft forever2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1442 qdisc fq_codel state UP group default qlen 1000    link/ether fa:16:3e:78:8b:9e brd ff:ff:ff:ff:ff:ff    altname enp0s3    altname ens3    inet 172.16.0.200/16 brd 172.16.255.255 scope global noprefixroute eth0       valid_lft forever preferred_lft forever    inet6 fe80::f816:3eff:fe78:8b9e/64 scope link        valid_lft forever preferred_lft forever3: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1442 qdisc fq_codel state UP group default qlen 1000    link/ether fa:16:3e:87:ca:cd brd ff:ff:ff:ff:ff:ff    altname enp0s7    altname ens7    inet 10.0.200.244/24 brd 10.0.200.255 scope global dynamic noprefixroute eth1       valid_lft 43193sec preferred_lft 43193sec    inet6 fe80::7f34:f482:b58c:edcc/64 scope link noprefixroute        valid_lft forever preferred_lft foreverAhora, nos salimos de la instancia y revocamos la red-intra-pablo:pavlo@debian:~/OpenStack()$ openstack server remove network zoro red-intra-pabloMás tarde, modificamos el fichero ~/.ssh/config para que acceda con la nueva IP:Host luffy  HostName 172.22.200.100  User pablo  ForwardAgent yesHost zoro  HostName 172.16.0.200  User pablo  ForwardAgent yes  ProxyJump luffyY ya nos dejaría acceder:pavlo@debian:~/OpenStack()$ ssh zoro The authenticity of host '172.16.0.200 (&lt;no hostip for proxy command&gt;)' can't be established.ED25519 key fingerprint is SHA256:JrbuXBRRZ4JoLGdRCCiKNThDEKWqINQtX2NVLKP7Gvo.This host key is known by the following other names/addresses:    ~/.ssh/known_hosts:421: [hashed name]    ~/.ssh/known_hosts:424: [hashed name]Are you sure you want to continue connecting (yes/no/[fingerprint])? yesWarning: Permanently added '172.16.0.200' (ED25519) to the list of known hosts.Last login: Thu Dec 12 08:30:57 2024 from 10.0.200.231[pablo@zoro ~]$Antes de probar la conexión a Internet debemos deshabilitar la seguridad de los puertos para que el NAT funcione correctamente:pavlo@debian:~/OpenStack()$ openstack port list --server zoro+--------------------------------------+-------------+-------------------+-----------------------------------------------------------------------------+--------+| ID                                   | Name        | MAC Address       | Fixed IP Addresses                                                          | Status |+--------------------------------------+-------------+-------------------+-----------------------------------------------------------------------------+--------+| 3dd6bcc3-0c30-4f37-ae10-3d70767efff1 | puerto-zoro | fa:16:3e:78:8b:9e | ip_address='172.16.0.200', subnet_id='450496f9-646a-42a4-9a8e-b07b5b3a992d' | ACTIVE |+--------------------------------------+-------------+-------------------+-----------------------------------------------------------------------------+--------+pavlo@debian:~/OpenStack()$ openstack port set 3dd6bcc3-0c30-4f37-ae10-3d70767efff1 --no-security-group --disable-port-securityPudiendo de esta forma acceder a Internet:[pablo@zoro ~]$ ping -c 4 8.8.8.8PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.64 bytes from 8.8.8.8: icmp_seq=1 ttl=103 time=18.0 ms64 bytes from 8.8.8.8: icmp_seq=2 ttl=103 time=17.8 ms64 bytes from 8.8.8.8: icmp_seq=3 ttl=103 time=17.6 ms64 bytes from 8.8.8.8: icmp_seq=4 ttl=103 time=17.1 ms--- 8.8.8.8 ping statistics ---4 packets transmitted, 4 received, 0% packet loss, time 3005msrtt min/avg/max/mdev = 17.086/17.607/17.958/0.325 msYa habríamos terminado la primera parte del escenario de OpenStack, quedando la topología de la siguiente forma:Si queremos hacer algunas comprobaciones como por ejemplo acceder a los FQDN del otro, tendremos que configurar los /etc/hosts:pablo@luffy:~$ cat /etc/hosts127.0.0.1\tlocalhost::1\t\tlocalhost ip6-localhost ip6-loopbackff02::1\t\tip6-allnodesff02::2\t\tip6-allrouters172.16.0.16 luffy.pablo.gonzalonazareno.org luffy172.16.0.200 zoro.pablo.gonzalonazareno.org zoro[pablo@zoro ~]$ cat /etc/hosts127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4::1         localhost localhost.localdomain localhost6 localhost6.localdomain6172.16.0.16 luffy.pablo.gonzalonazareno.org luffy172.16.0.200 zoro.pablo.gonzalonazareno.org zoroDe forma que tenemos conectividad entre ambos:pablo@luffy:~$ ping -c 2 zoro.pablo.gonzalonazareno.org PING zoro.pablo.gonzalonazareno.org (172.16.0.200) 56(84) bytes of data.64 bytes from zoro.pablo.gonzalonazareno.org (172.16.0.200): icmp_seq=1 ttl=64 time=2.40 ms64 bytes from zoro.pablo.gonzalonazareno.org (172.16.0.200): icmp_seq=2 ttl=64 time=0.510 ms--- zoro.pablo.gonzalonazareno.org ping statistics ---2 packets transmitted, 2 received, 0% packet loss, time 1002msrtt min/avg/max/mdev = 0.510/1.457/2.404/0.947 ms[pablo@zoro ~]$ ping -c 2 luffy.pablo.gonzalonazareno.orgPING luffy.pablo.gonzalonazareno.org (172.16.0.16) 56(84) bytes of data.64 bytes from luffy.pablo.gonzalonazareno.org (172.16.0.16): icmp_seq=1 ttl=64 time=0.218 ms64 bytes from luffy.pablo.gonzalonazareno.org (172.16.0.16): icmp_seq=2 ttl=64 time=0.441 ms--- luffy.pablo.gonzalonazareno.org ping statistics ---2 packets transmitted, 2 received, 0% packet loss, time 1026msrtt min/avg/max/mdev = 0.218/0.329/0.441/0.111 msPor último, podemos ver que tenemos conectividad a Internet en ambas máquinas:pablo@luffy:~$ ping -c 2 google.comPING google.com (142.250.186.78) 56(84) bytes of data.64 bytes from fra24s05-in-f14.1e100.net (142.250.186.78): icmp_seq=1 ttl=101 time=40.0 ms64 bytes from fra24s05-in-f14.1e100.net (142.250.186.78): icmp_seq=2 ttl=101 time=38.2 ms--- google.com ping statistics ---2 packets transmitted, 2 received, 0% packet loss, time 1002msrtt min/avg/max/mdev = 38.183/39.114/40.045/0.931 ms[pablo@zoro ~]$ ping -c 2 google.comPING google.com (142.250.186.78) 56(84) bytes of data.64 bytes from fra24s05-in-f14.1e100.net (142.250.186.78): icmp_seq=1 ttl=100 time=40.4 ms64 bytes from fra24s05-in-f14.1e100.net (142.250.186.78): icmp_seq=2 ttl=100 time=37.1 ms--- google.com ping statistics ---2 packets transmitted, 2 received, 0% packet loss, time 1001msrtt min/avg/max/mdev = 37.124/38.739/40.355/1.615 ms"
  },
  
  {
    "title": "Instalación de Oracle 19c en Debian 12",
    "url": "/posts/instalacion-oracle19c/",
    "categories": "Base de Datos, Instalación",
    "tags": "Instalación",
    "date": "2024-11-15 18:15:00 +0100",
    





    
    "snippet": "IntroducciónEn este post, voy a detallar el proceso de instalación de Oracle 19c en una máquina virtual con Debian 12, utilizando QEMU/KVM como plataforma de virtualización. Para este tipo de insta...",
    "content": "IntroducciónEn este post, voy a detallar el proceso de instalación de Oracle 19c en una máquina virtual con Debian 12, utilizando QEMU/KVM como plataforma de virtualización. Para este tipo de instalación, es fundamental asegurarse de que la máquina virtual tenga recursos suficientes para que Oracle funcione correctamente. En este caso, se recomienda asignar al menos 4096 MB de memoria RAM, 4 núcleos de procesador (cores) y 40 GB de almacenamiento. Estos recursos permitirán que la base de datos funcione de manera estable, incluso en entornos de prueba o desarrollo.La máquina virtual se configurará con la red “default”, lo que le asignará automáticamente una dirección IP dentro del rango 192.168.122.x/24. Esta configuración de red es ideal para comunicaciones internas entre la máquina virtual y el sistema host, así como para facilitar la instalación y acceso remoto, si es necesario, sin complicaciones adicionales en cuanto a configuraciones de red. A continuación, explicaré detalladamente cómo configurar todo el entorno y proceder con la instalación de Oracle 19c paso a paso.InstalaciónEn este caso, se está configurando una red estática en la máquina virtual que va a hospedar Oracle 19c. Esta configuración es importante porque permite tener un control más preciso sobre la dirección IP de la máquina virtual, lo cual es crucial para garantizar que el sistema sea accesible y que la comunicación con otros dispositivos de la red no se vea interrumpida, especialmente cuando se trabaja con bases de datos como Oracle, que requieren un acceso constante y estable.Configuración de la interfaz de red estáticaEl archivo /etc/network/interfaces en Debian es el encargado de definir cómo se gestionan las interfaces de red. En este caso, se está configurando la interfaz de red enp1s0 con una dirección IP estática:pablo@oracle-server:~$ cat /etc/network/interfaces# This file describes the network interfaces available on your system# and how to activate them. For more information, see interfaces(5).source /etc/network/interfaces.d/*# The loopback network interfaceauto loiface lo inet loopback# The primary network interface#allow-hotplug enp1s0#iface enp1s0 inet dhcpauto enp1s0iface enp1s0 inet static\taddress 192.168.122.126\tnetmask 255.255.255.0\tgateway 192.168.122.1Configuración del archivo /etc/hostsEl archivo /etc/hosts se utiliza para mapear direcciones IP a nombres de host. En este caso, se ha añadido una entrada para la dirección IP estática que se configuró en el paso anterior, asociándola al nombre oracle-server:pablo@oracle-server:~$ cat /etc/hosts127.0.0.1\tlocalhost127.0.1.1\toracle-server# The following lines are desirable for IPv6 capable hosts::1     localhost ip6-localhost ip6-loopbackff02::1 ip6-allnodesff02::2 ip6-allrouters192.168.122.126\toracle-serverLa combinación de una red estática con la entrada en /etc/hosts garantiza que la máquina virtual siempre tendrá la misma dirección IP en la red y que será posible referenciarla mediante un nombre fácil de recordar, como oracle-server, tanto en la máquina virtual como en otros dispositivos o aplicaciones que necesiten comunicarse con ella.Cuando realizas una instalación de Oracle 19c en Debian 12, uno de los primeros pasos que debes hacer es asegurarte de que el sistema esté completamente actualizado y tenga todas las dependencias necesarias para que Oracle funcione sin problemas. Para ello, realizarás dos comandos importantes que explico a continuación:pablo@oracle-server:~$ sudo apt update &amp;&amp; sudo apt upgrade -yObj:1 http://deb.debian.org/debian bookworm InReleaseObj:2 http://security.debian.org/debian-security bookworm-security InReleaseObj:3 http://deb.debian.org/debian bookworm-updates InReleaseLeyendo lista de paquetes... HechoCreando árbol de dependencias... HechoLeyendo la información de estado... HechoTodos los paquetes están actualizados.Leyendo lista de paquetes... HechoCreando árbol de dependencias... HechoLeyendo la información de estado... HechoCalculando la actualización... Hecho0 actualizados, 0 nuevos se instalarán, 0 para eliminar y 0 no actualizados.E instalamos las dependencias necesarias:pablo@oracle-server:~$ sudo apt install libaio1 unixodbc bc ksh gawk -yEste comando instala una serie de paquetes necesarios para el funcionamiento de Oracle 19c. Cada uno de estos paquetes cumple una función específica dentro del entorno de Oracle y en la configuración del sistema:      libaio1: Este paquete instala las bibliotecas de entrada/salida asíncrona (AIO) necesarias para Oracle. Oracle utiliza AIO para realizar operaciones de lectura y escritura sin bloquear el proceso, lo que mejora el rendimiento de la base de datos. Este es un requisito fundamental para que Oracle funcione correctamente en el sistema.        unixodbc: Este paquete proporciona las bibliotecas y herramientas necesarias para gestionar la conectividad con bases de datos mediante ODBC (Open Database Connectivity). Aunque Oracle no siempre utiliza ODBC para la conectividad por defecto, algunas herramientas o configuraciones de Oracle pueden requerir este paquete para establecer conexiones a otras bases de datos o para ciertos procesos internos.        bc: Este paquete instala una calculadora de precisión arbitraria, que es útil en muchos scripts y procesos de Oracle. Se usa, por ejemplo, para realizar cálculos matemáticos en la configuración o en la ejecución de scripts de mantenimiento y automatización de la base de datos.        ksh: Este es el KornShell, un intérprete de comandos compatible con muchos de los scripts utilizados por Oracle. Aunque Oracle puede funcionar con otros shells, como bash, ciertos scripts y herramientas de Oracle requieren específicamente el KornShell para funcionar correctamente.        gawk: Este paquete instala la versión GNU de AWK, que es un potente lenguaje de programación utilizado para procesamiento de texto y manipulación de datos. Oracle utiliza AWK en muchos de sus scripts de configuración y mantenimiento, por lo que es necesario tenerlo instalado para que los scripts internos de Oracle se ejecuten correctamente.  Oracle utiliza un enfoque de administración basado en roles, por lo que es importante crear un grupo y un usuario específico para garantizar que el sistema esté organizado y que las tareas administrativas puedan realizarse de manera controlada. Para ello:pablo@oracle-server:~$ sudo groupadd dbapablo@oracle-server:~$ sudo adduser --ingroup dba --home /home/oracle --shell /bin/bash oracleAñadiendo el usuario `oracle' ...Adding new user `oracle' (1001) with group `dba (1001)' ...Creando el directorio personal `/home/oracle' ...Copiando los ficheros desde `/etc/skel' ...Nueva contraseña: Vuelva a escribir la nueva contraseña: passwd: contraseña actualizada correctamenteCambiando la información de usuario para oracleIntroduzca el nuevo valor, o pulse INTRO para usar el valor predeterminado\tNombre completo []: \tNúmero de habitación []: \tTeléfono del trabajo []: \tTeléfono de casa []: \tOtro []: ¿Es correcta la información? [S/n] Adding new user `oracle' to supplemental / extra groups `users' ...Añadiendo al usuario `oracle' al grupo `users' ...En este paso del proceso de instalación de Oracle 19c, es importante mencionar que, aunque Oracle ofrece soporte para varias distribuciones de Linux, no proporciona soporte oficial para Debian. Esto significa que no existe un paquete .deb directamente disponible para instalar Oracle en Debian. Sin embargo, existen formas de sortear este inconveniente.Obtención del fichero de instalaciónEl primer paso es descargar el archivo de instalación desde la página oficial de Oracle. Para ello, tendrás que acceder a la sección de descargas de Oracle en su sitio web, donde podrás encontrar el instalador correspondiente para Oracle 19c. Generalmente, Oracle proporciona el instalador en formato .rpm para sistemas basados en Red Hat, como CentOS o RHEL, pero no ofrece un paquete .deb directamente para Debian. Esto se debe a que Debian y sus derivados (como Ubuntu) utilizan un sistema de gestión de paquetes diferente, basado en el formato .deb.Conversión del paquete .rpm a .deb usando alienDado que Oracle no ofrece un paquete nativo de Debian, una de las opciones es utilizar una herramienta llamada alien para convertir el paquete .rpm (Red Hat Package Manager) a un formato .deb compatible con Debian.alien es una herramienta que permite convertir entre diferentes formatos de paquetes de Linux, incluyendo .rpm a .deb. Aunque la conversión no es perfecta en todos los casos, generalmente funciona bien para muchos paquetes.Para realizar la conversión, primero necesitas instalar alien en tu sistema Debian:sudo apt install alienUna vez instalado alien, puedes convertir el archivo .rpm a .deb con el siguiente comando:sudo alien -d oracle-database-ee-19c-1.0-1.x86_64.rpm  El parámetro -d le indica a alien que cree un paquete .deb. Este proceso generará un archivo .deb que podrás instalar de manera estándar en tu sistema Debian utilizando dpkg.Proceso ya realizadoComo ya he realizado esta conversión previamente, para aligerar el proceso, he subido el paquete .deb a un servicio de almacenamiento en la nube, como Mega, para que puedas descargarlo directamente sin necesidad de hacer la conversión tú mismo.Dejaré el link de descarga de este paquete .deb para que puedas instalar Oracle 19c sin complicaciones adicionales. Solo tendrás que descargar el archivo:MegaUna vez que hayas descargado el archivo .deb de Oracle 19c, el siguiente paso es transferir este fichero a la máquina virtual donde realizarás la instalación. Para ello, utilizaremos el comando scp (Secure Copy), que es una herramienta segura para transferir archivos entre sistemas a través de SSH.El comando que he utilizado es el siguiente:pavlo@debian:~()$ scp /home/pavlo/iso/oracle-database-ee-19c_1.0-2_amd64.deb pablo@192.168.122.126:/home/pablopablo@192.168.122.126's password: oracle-database-ee-19c_1.0-2_amd64.deb                                                                                                     100% 2409MB 101.4MB/s   00:23Y como podemos ver ya lo tenemos en nuestra máquina virtual:pablo@oracle-server:~$ lsoracle-database-ee-19c_1.0-2_amd64.debUna vez que hemos transferido el archivo .deb de Oracle Database 19c a nuestra máquina virtual, es hora de proceder con la instalación. Para ello, usaremos el comando dpkg, que es el gestor de paquetes estándar en Debian. Aquí te dejo cómo hacerlo.pablo@oracle-server:~$ sudo dpkg -i oracle-database-ee-19c_1.0-2_amd64.deb [sudo] contraseña para pablo: Seleccionando el paquete oracle-database-ee-19c previamente no seleccionado.(Leyendo la base de datos ... 34459 ficheros o directorios instalados actualmente.)Preparando para desempaquetar oracle-database-ee-19c_1.0-2_amd64.deb ...ln: fallo al crear el enlace simbólico '/bin/awk': El fichero ya existeDesempaquetando oracle-database-ee-19c (1.0-2) ...Configurando oracle-database-ee-19c (1.0-2) ...[INFO] Executing post installation scripts...[INFO] Oracle home installed successfully and ready to be configured.To configure a sample Oracle Database you can execute the following service configuration script as root: /etc/init.d/oracledb_ORCLCDB-19c configureProcesando disparadores para libc-bin (2.36-9+deb12u9) ...Una vez hecho esto, ya es hora de comenzar la instalación, pero antes recomiendo borrar el contenido del fichero /etc/init.d/oracledb_ORCLCDB-19c y añadir el siguiente contenido modificado:#!/bin/bash## chkconfig: 2345 80 05# Description: This script is responsible for taking care of configuring the Oracle Database and its associated services.## processname: oracledb_ORCLCDB-19c# Red Hat or SuSE config: /etc/sysconfig/oracledb_ORCLCDB-19c## Set path if path not setcase $PATH in    \"\") PATH=/bin:/usr/bin:/sbin:/etc         export PATH ;;esac# Check if the root user is running this scriptif [ $(id -u) != \"0\" ]then    echo \"You must be root user to run the configurations script. Login as root user and try again.\"    exit 1fi# Setting the required environment variablesexport ORACLE_HOME=/opt/oracle/product/19c/dbhome_1export ORACLE_VERSION=19c export ORACLE_SID=ORCLCDBexport TEMPLATE_NAME=General_Purpose.dbcexport CHARSET=AL32UTF8export PDB_NAME=ORCLPDB1export LISTENER_NAME=LISTENERexport NUMBER_OF_PDBS=1export CREATE_AS_CDB=true# General exports and varsexport PATH=$ORACLE_HOME/bin:$PATHLSNR=$ORACLE_HOME/bin/lsnrctlSQLPLUS=$ORACLE_HOME/bin/sqlplusDBCA=$ORACLE_HOME/bin/dbcaNETCA=$ORACLE_HOME/bin/netcaORACLE_OWNER=oracleRETVAL=0CONFIG_NAME=\"oracledb_$ORACLE_SID-$ORACLE_VERSION.conf\"CONFIGURATION=\"/etc/sysconfig/$CONFIG_NAME\"# Commandsif [ -z \"$SU\" ];then SU=/bin/su; fiif [ -z \"$GREP\" ]; then GREP=/usr/bin/grep; fiif [ ! -f \"$GREP\" ]; then GREP=/bin/grep; fi# To start the DBstart(){    check_for_configuration    RETVAL=$?    if [ $RETVAL -eq 1 ]    then        echo \"The Oracle Database is not configured. You must run '/etc/init.d/oracledb_$ORACLE_SID-$ORACLE_VERSION configure' as the root user to configure the database.\"        exit    fi    # Check if the DB is already started    pmon=ps -ef | egrep pmon_$ORACLE_SID'\\&gt;' | $GREP -v grep    if [ \"$pmon\" = \"\" ];    then        # Unset the proxy env vars before calling sqlplus        unset_proxy_vars        echo \"Starting Oracle Net Listener.\"        $SU -s /bin/bash $ORACLE_OWNER -c \"$LSNR  start $LISTENER_NAME\" &gt; /dev/null 2&gt;&amp;1        RETVAL=$?        if [ $RETVAL -eq 0 ]        then            echo \"Oracle Net Listener started.\"        fi        echo \"Starting Oracle Database instance $ORACLE_SID.\"        $SU -s /bin/bash  $ORACLE_OWNER -c \"$SQLPLUS -s /nolog &lt;&lt; EOF                                                                connect / as sysdba                                                                startup                                                                alter pluggable database all open                                                                exit;                                                                EOF\" &gt; /dev/null 2&gt;&amp;1        RETVAL1=$?        if [ $RETVAL1 -eq 0 ]        then            echo \"Oracle Database instance $ORACLE_SID started.\"        fi    else        echo \"The Oracle Database instance $ORACLE_SID is already started.\"        exit 0    fi    echo    if [ $RETVAL -eq 0 ] &amp;&amp; [ $RETVAL1 -eq 0 ]    then        return 0     else        echo \"Failed to start Oracle Net Listener using $ORACLE_HOME/bin/tnslsnr and Oracle Database using $ORACLE_HOME/bin/sqlplus.\"        exit 1    fi}# To stop the DBstop(){    check_for_configuration    RETVAL=$?    if [ $RETVAL -eq 1 ]    then        echo \"The Oracle Database is not configured. You must run '/etc/init.d/oracledb_$ORACLE_SID-$ORACLE_VERSION configure' as the root user to configure the database.\"        exit 1    fi    # Check if the DB is already stopped    pmon=ps -ef | egrep pmon_$ORACLE_SID'\\&gt;' | $GREP -v grep    if [ \"$pmon\" = \"\" ]    then        echo \"Oracle Database instance $ORACLE_SID is already stopped.\"        exit 1    else        # Unset the proxy env vars before calling sqlplus        unset_proxy_vars        echo \"Shutting down Oracle Database instance $ORACLE_SID.\"        $SU -s /bin/bash $ORACLE_OWNER -c \"$SQLPLUS -s /nolog &lt;&lt; EOF                                                                connect / as sysdba                                                                shutdown immediate                                                                exit;                                                                EOF\" &gt; /dev/null 2&gt;&amp;1        RETVAL=$?        if [ $RETVAL -eq 0 ]        then            echo \"Oracle Database instance $ORACLE_SID shut down.\"        fi        echo \"Stopping Oracle Net Listener.\"        $SU -s /bin/bash  $ORACLE_OWNER -c \"$LSNR stop $LISTENER_NAME\" &gt; /dev/null 2&gt;&amp;1        RETVAL1=$?        if [ $RETVAL1 -eq 0 ]        then            echo \"Oracle Net Listener stopped.\"        fi    fi    echo    if [ $RETVAL -eq 0 ] &amp;&amp; [ $RETVAL1 -eq 0 ]    then        return 0    else        echo \"Failed to stop Oracle Net Listener using $ORACLE_HOME/bin/tnslsnr and Oracle Database using $ORACLE_HOME/bin/sqlplus.\"        exit 1    fi}# To call DBCA to configure the DBconfigure_perform(){    # Unset the proxy env vars before calling dbca    unset_proxy_vars    echo \"Configuring Oracle Database $ORACLE_SID.\"    # Add the -J-Doracle.assistants.dbca.validate.ConfigurationParams=false to bypass the memory validation error    $SU -s /bin/bash  $ORACLE_OWNER -c \"$DBCA -silent -createDatabase -gdbName $ORACLE_SID -templateName $TEMPLATE_NAME -characterSet $CHARSET -createAsContainerDatabase $CREATE_AS_CDB -numberOfPDBs $NUMBER_OF_PDBS -pdbName $PDB_NAME -createListener $LISTENER_NAME:$LISTENER_PORT -datafileDestination $ORACLE_DATA_LOCATION -sid $ORACLE_SID -autoGeneratePasswords -emConfiguration DBEXPRESS -emExpressPort $EM_EXPRESS_PORT -J-Doracle.assistants.dbca.validate.ConfigurationParams=false\"    RETVAL=$?    echo    if [ $RETVAL -eq 0 ]    then        echo \"Database configuration completed successfully. The passwords were auto generated, you must change them by connecting to the database using 'sqlplus / as sysdba' as the oracle user.\"        return 0    else        echo \"Database configuration failed.\"        exit 1    fi}# Enh 27965939 - Unsets the proxy env variablesunset_proxy_vars(){    if [ \"$http_proxy\" != \"\" ]    then        unset http_proxy    fi    if [ \"$HTTP_PROXY\" != \"\" ]    then        unset HTTP_PROXY    fi    if [ \"$https_proxy\" != \"\" ]    then        unset https_proxy    fi    if [ \"$HTTPS_PROXY\" != \"\" ]    then        unset HTTPS_PROXY    fi}# Check if the DB is already configuredcheck_for_configuration(){    configfile=$GREP --no-messages $ORACLE_SID:$ORACLE_HOME /etc/oratab &gt; /dev/null 2&gt;&amp;1    if [ \"$configfile\" = \"\" ]    then        return 1    fi    return 0}read_config_file(){    if [ -f \"$CONFIGURATION\" ]    then        . \"$CONFIGURATION\"    else        echo \"The Oracle Database is not configured. Unable to read the configuration file '$CONFIGURATION'\"        exit 1;    fi}# Entry point to configure the DBconfigure(){    check_for_configuration    RETVAL=$?    if [ $RETVAL -eq 0 ]    then        echo \"Oracle Database instance $ORACLE_SID is already configured.\"        exit 1    fi    read_config_file    check_port_availability    check_em_express_port_availability    configure_perform}check_port_availability(){    port=netstat -n --tcp --listen | $GREP :$LISTENER_PORT    if [ \"$port\" != \"\" ]    then        echo \"Port $LISTENER_PORT appears to be in use by another application. Specify a different port in the configuration file.\"        exit 1    fi}check_em_express_port_availability(){    port=netstat -n --tcp --listen | $GREP :$EM_EXPRESS_PORT    if [ \"$port\" != \"\" ]    then        echo \"Port $EM_EXPRESS_PORT appears to be in use by another application. Specify a different port in the configuration file.\"        exit 1    fi}case \"$1\" in    start)        start        ;;    stop)        stop        ;;    restart)        stop        start        ;;    configure)        configure        ;;    *)        echo \"Usage: $0 {start|stop|restart|configure}\"        exit 1esacEsto es porque por defecto el contenido del script del fichero configure me daba problemas, por lo que con estas modificaciones me funciona correctamente.Ahora, ya solo nos queda ejecutar el comando de la instalación y esperar. Este proceso puede tardar varios minutos.pablo@oracle-server:~$ sudo /etc/init.d/oracledb_ORCLCDB-19c configure/etc/init.d/oracledb_ORCLCDB-19c: línea 243: -n: orden no encontrada/etc/init.d/oracledb_ORCLCDB-19c: línea 253: -n: orden no encontradaConfiguring Oracle Database ORCLCDB.Preparar para funcionamiento de base de datos8% finalizadoCopiando archivos de base de datos31% finalizadoCreando e iniciando instancia Oracle32% finalizado36% finalizado40% finalizado43% finalizado46% finalizadoTerminando creación de base de datos51% finalizado54% finalizadoCreando Bases de Datos de Conexión58% finalizado77% finalizadoEjecutando acciones posteriores a la configuración100% finalizadoCreación de la base de datos terminada. Consulte los archivos log de /opt/oracle/cfgtoollogs/dbca/ORCLCDB para obtener más información.Información de Base de Datos:Nombre de la Base de Datos Global:ORCLCDBIdentificador del Sistema (SID):ORCLCDBPara obtener información detallada, consulte el archivo log \"/opt/oracle/cfgtoollogs/dbca/ORCLCDB/ORCLCDB.log\".Database configuration completed successfully. The passwords were auto generated, you must change them by connecting to the database using 'sqlplus / as sysdba' as the oracle user.ConfiguraciónAl finalizar la ejecución del script de configuración de Oracle Database, se indica que la base de datos ha sido configurada exitosamente. Sin embargo, antes de poder usar Oracle como el usuario oracle, es necesario configurar las variables de entorno adecuadas para garantizar que el sistema pueda encontrar las herramientas y archivos correctos de Oracle. Estas variables definen el entorno en el que Oracle se ejecuta, y se deben configurar correctamente para que los comandos de Oracle funcionen sin problemas. Por lo tanto, nos cambiamos al usuario oracle y en el fichero ~/.bashrc añadimos las variables al final:pablo@oracle-server:~$ sudo su - oracleoracle@oracle-server:~$ tail -6 ~/.bashrc #Oracle environmentsexport ORACLE_HOME=/opt/oracle/product/19c/dbhome_1export ORACLE_SID=ORCLCDBexport ORACLE_BASE=/opt/oracleexport PATH=$ORACLE_HOME/bin:$PATHexport LD_LIBRARY_PATH=$ORACLE_HOME/lib:$LD_LIBRARY_PATHoracle@oracle-server:~$ source ~/.bashrcUna vez que hemos añadido las variables de entorno necesarias en el archivo .bashrc del usuario oracle y hemos recargado dicho archivo, las herramientas de Oracle deberían estar completamente configuradas para su uso. Esto nos permite acceder a la base de datos utilizando comandos como sqlplus, que es la herramienta de línea de comandos de Oracle para interactuar con la base de datos.oracle@oracle-server:~$ sqlplus / as sysdbaSQL*Plus: Release 19.0.0.0.0 - Production on Tue Nov 19 13:33:37 2024Version 19.3.0.0.0Copyright (c) 1982, 2019, Oracle.  All rights reserved.Conectado a:Oracle Database 19c Enterprise Edition Release 19.0.0.0.0 - ProductionVersion 19.3.0.0.0SQL&gt;💡 Tip: El comando rlwrap es una herramienta muy útil que mejora la experiencia de uso de programas de línea de comandos que no tienen soporte nativo para edición de texto o historial de comandos. En el contexto de Oracle y herramientas como SQL*Plus, rlwrap puede ser un gran aliado al proporcionar características de edición y autocompletado que, de otra manera, no estarían disponibles.Primero de todo lo instalamos:oracle@oracle-server:~$ sudo apt install rlwrapPara aprovechar la funcionalidad de rlwrap de manera automática cada vez que iniciemos SQLPlus, podemos añadir el comando rlwrap a las variables de entorno del usuario oracle. Esto hará que SQLPlus siempre se ejecute con las ventajas de rlwrap, sin tener que escribir el comando completo cada vez. Por lo tanto, en el ~/.bashrc añadimos la siguiente línea:alias sqlplus='rlwrap sqlplus'Recargamos:oracle@oracle-server:~$ source ~/.bashrcY ahora cada vez que accedamos a la terminal de sqlplus lo tendremos a modo terminal, donde podremos recuperar comandos, hacer Ctrl + l, etc.Añadir usuario principalEn el proceso de configuración de la base de datos Oracle, hemos visto que podemos acceder a la base de datos desde el usuario oracle, dado que previamente le otorgamos los permisos necesarios. Sin embargo, generalmente no vamos a querer realizar todas las tareas administrativas directamente desde el usuario oracle, ya que este es un usuario dedicado principalmente a gestionar Oracle, y preferimos usar nuestro propio usuario principal para interactuar con el sistema, a menos que se nos indique lo contrario.Para poder administrar la base de datos desde nuestro usuario principal, necesitamos agregarlo al grupo dba que creamos anteriormente. Esto nos permitirá tener acceso a las herramientas y permisos necesarios para gestionar Oracle como si fuéramos administradores, sin tener que cambiar de usuario constantemente.Además, debemos asegurarnos de que las variables de entorno relacionadas con Oracle estén configuradas correctamente en nuestro usuario principal, de manera que podamos acceder a las herramientas de Oracle (como SQL*Plus) y ejecutar comandos administrativos desde nuestro propio entorno de usuario.pablo@oracle-server:~$ sudo usermod -a -G dba pablo[sudo] contraseña para pablo: pablo@oracle-server:~$ sudo nano ~/.bashrcpablo@oracle-server:~$ source ~/.bashrcpablo@oracle-server:~$ sqlplus / as sysdbaSQL*Plus: Release 19.0.0.0.0 - Production on Tue Nov 19 13:49:52 2024Version 19.3.0.0.0Copyright (c) 1982, 2019, Oracle.  All rights reserved.Conectado a:Oracle Database 19c Enterprise Edition Release 19.0.0.0.0 - ProductionVersion 19.3.0.0.0SQL&gt; Creación de un usuario en Oracle 19cAl trabajar con Oracle Database, una de las tareas más comunes es la creación de usuarios. Sin embargo, en algunas configuraciones recientes, como la que estamos utilizando en Oracle 19c, puede surgir un error relacionado con el parámetro _ORACLE_SCRIPT. Aquí te explicamos cómo crear un usuario y cómo resolver este problema si aparece.Creación de un usuario en OraclePara crear un usuario en Oracle Database, seguimos estos pasos:Accedemos a la base de datos con privilegios de administrador utilizando SQL*Plus:pablo@oracle-server:~$ sqlplus / as sysdbaSQL*Plus: Release 19.0.0.0.0 - Production on Tue Nov 19 13:58:52 2024Version 19.3.0.0.0Copyright (c) 1982, 2019, Oracle.  All rights reserved.Conectado a:Oracle Database 19c Enterprise Edition Release 19.0.0.0.0 - ProductionVersion 19.3.0.0.0Y creamos el nuevo usuario:SQL&gt; CREATE USER pablo IDENTIFIED BY password;CREATE USER pablo IDENTIFIED BY password            *ERROR en linea 1:ORA-65096: nombre de usuario o rol comun no validoPero como podemos ver nos ha dado error. Este error ocurre porque Oracle 12c y versiones posteriores introdujeron el concepto de bases de datos multitenant, donde una única instancia puede contener múltiples bases de datos “pluggable” (PDB). De forma predeterminada, Oracle espera que los nombres de usuario sigan ciertas convenciones especiales para usuarios “comunes” que se compartan entre las bases de datos contenedoras (CDB) y las bases de datos pluggable (PDB).Si no estamos configurando un usuario común, sino uno específico para nuestra base de datos pluggable, necesitamos desactivar temporalmente esta restricción.Para solucionarlo tendremos que ejecutar el siguiente comando:ALTER SESSION SET \"_ORACLE_SCRIPT\"=TRUE;Y ya nos dejará crear el usuario sin problemas:SQL&gt; ALTER SESSION SET \"_ORACLE_SCRIPT\"=TRUE;Sesion modificada.SQL&gt; CREATE USER pablo IDENTIFIED BY password;Usuario creado.Le damos permisos para conectarnos:SQL&gt; GRANT CONNECT, RESOURCE TO pablo;Concesion terminada correctamente.Y probamos a conectarnos con el nuevo usuario:pablo@oracle-server:~$ sqlplus pablo/passwordSQL*Plus: Release 19.0.0.0.0 - Production on Tue Nov 19 14:05:34 2024Version 19.3.0.0.0Copyright (c) 1982, 2019, Oracle.  All rights reserved.Conectado a:Oracle Database 19c Enterprise Edition Release 19.0.0.0.0 - ProductionVersion 19.3.0.0.0SQL&gt;Con esto concluimos la instalación y configuración de Oracle Database 19c sobre una máquina virtual con Debian 12, utilizando QEMU/KVM como hipervisor. A lo largo de este proceso, hemos cubierto todos los aspectos necesarios para poner en marcha la base de datos, desde la configuración inicial del sistema operativo hasta los pasos específicos para preparar y personalizar el entorno de Oracle.Hemos abordado detalles importantes como la instalación de dependencias, la creación de usuarios y grupos, la gestión de variables de entorno y la resolución de errores comunes. Además, vimos cómo realizar tareas básicas de administración, como el acceso a SQL*Plus, la adición de usuarios y el uso de herramientas útiles como rlwrap para mejorar la experiencia en la línea de comandos."
  },
  
  {
    "title": "Instalación de WordPress en un servidor LEMP",
    "url": "/posts/instalacion-wordpress/",
    "categories": "Implantación Web, Aplicaciones",
    "tags": "Aplicaciones",
    "date": "2024-11-15 18:15:00 +0100",
    





    
    "snippet": "¿Qué vas a aprender en este taller?  Realizar la instalación de un servidor LEMP.  Configurar nginx como proxy inverso para pasar las peticiones PHP al servidor de aplicación fpm-php.  Realizar la ...",
    "content": "¿Qué vas a aprender en este taller?  Realizar la instalación de un servidor LEMP.  Configurar nginx como proxy inverso para pasar las peticiones PHP al servidor de aplicación fpm-php.  Realizar la instalación de un CMS PHP WordPress.Instalación de la pila LEMPEn este taller configuraremos una máquina virtual con Debian 12 y un servidor LEMP.¿Qué es LEMP?LEMP es un conjunto de software diseñado para alojar aplicaciones web dinámicas. A continuación, desglosamos sus componentes:  L: Linux, el sistema operativo base.  E: Nginx, el servidor web, conocido por su rendimiento y eficiencia. (Se pronuncia “Engine-X”)  M: MySQL o MariaDB, sistemas de gestión de bases de datos utilizados para almacenar información.  P: PHP, un lenguaje de programación para generar contenido dinámico en páginas web.Es una alternativa moderna al stack LAMP (que utiliza Apache como servidor web).Pasos para instalar la pila LEMP:Ejecuta el siguiente comando para instalar Nginx:pablo@debian:~$ sudo apt install nginx -yInstala MariaDB para gestionar las bases de datos necesarias:pablo@debian:~$ sudo apt install mariadb-server mariadb-client -yAgrega PHP y los módulos imprescindibles para que WordPress funcione correctamente:pablo@debian:~$ sudo apt install php-fpm php-mysql php-xml php-mbstring php-curl php-gd -yY listo, con estos pasos ya tendrás instalada y configurada la pila LEMP.Creación de la base de datosEn este paso, configuraremos la base de datos necesaria para WordPress. Esto incluye crear una base de datos específica, un usuario asociado y otorgarle los permisos necesarios. A continuación, te explico el proceso:1. Accede a la consola de MariaDB como usuario root, para ello ejecuta el siguiente comando en tu terminal:pablo@debian:~$ sudo mysql -u root -pIngresa la contraseña de root cuando se te solicite. Esto te llevará al monitor de MariaDB.2. Una vez dentro de MariaDB, ejecuta:CREATE DATABASE wordpress_db;Esto crea una base de datos llamada wordpress_db donde se almacenarán los datos de WordPress.3. Define un nuevo usuario y una contraseña para gestionar la base de datos. Por ejemplo:GRANT ALL PRIVILEGES ON wordpress_db.* TO 'user'@'localhost';  user: Nombre del usuario.  password: Contraseña asociada al usuario.4. Otorga todos los privilegios al usuario sobre la base de datos:GRANT ALL PRIVILEGES ON wordpress_db.* TO 'user'@'localhost';Permite al usuario user gestionar completamente la base de datos wordpress_db:5. Finalmente, actualiza los privilegios para asegurarte de que se registren correctamente:FLUSH PRIVILEGES;6. Sal del monitor de MariaDB:EXIT;Ahora tienes una base de datos llamada wordpress_db y un usuario user con todos los privilegios sobre ella. Estos datos serán utilizados durante la configuración de WordPress.Configurar un VirtualHost para WordPressEn este paso, crearemos y configuraremos un virtualhost en nginx para que el sitio web de WordPress sea accesible a través de un dominio local como wordpress.pablo.beer. A continuación, los pasos detallados:1. Crear el archivo de configuración del virtualhostEdita o crea un nuevo archivo de configuración en /etc/nginx/sites-available/ con el nombre del dominio deseado:pablo@debian:~$ sudo nano /etc/nginx/sites-available/wordpress.pablo.beerDentro del archivo, agrega la configuración:server {    listen 80;    server_name wordpress.pablo.beer;    root /var/www/wordpress;    index index.php index.html index.htm;    location / {        try_files $uri $uri/ /index.php?$args;    }    location ~ \\.php$ {        include snippets/fastcgi-php.conf;        fastcgi_pass unix:/var/run/php/php8.2-fpm.sock;    }    location ~ /\\.ht {        deny all;    }}2. Activar el VirtualHostCrea un enlace simbólico en el directorio sites-enabled para que nginx cargue esta configuración:pablo@debian:~$ sudo ln -s /etc/nginx/sites-available/wordpress.pablo.beer /etc/nginx/sites-enabled/3. Verificar la configuración de nginxAntes de reiniciar nginx, verifica que la configuración sea válida:pablo@debian:~$ sudo nginx -tSi todo está correcto, verás un mensaje indicando que la configuración es válida.4. Descargar WordPresspablo@debian:~$ cd /tmppablo@debian:/tmp$ wget https://wordpress.org/latest.zipDescomprime el archivo descargado:pablo@debian:/tmp$ sudo apt install unzippablo@debian:/tmp$ unzip latest.zip5. Mover WordPress a la ruta del servidor webMueve los archivos de WordPress al directorio especificado en la configuración del virtualhost (/var/www/wordpress):pablo@debian:/tmp$ sudo mv wordpress /var/www/wordpress6. Asignar permisos correctosAsegúrate de que los archivos y directorios tengan los permisos correctos:pablo@debian:~$ sudo chown -R www-data:www-data /var/www/wordpresspablo@debian:~$ sudo chmod -R 755 /var/www/wordpress7. Configurar el archivo hostsAñade el dominio local wordpress.pablo.beer en el archivo /etc/hosts de tu host principal (tu máquina física) para que el navegador lo reconozca. Edita el archivo de la siguiente manera:pavlo@debian:~()$ sudo nano /etc/hostsAgrega la línea:&lt;IP_Máquina_Virtual&gt;\twordpress.pablo.beer8. Reiniciar nginxReinicia el servicio para aplicar los cambios:pablo@debian:~$ sudo systemctl restart nginxAhora deberías poder acceder a WordPress escribiendo http://wordpress.pablo.beer en tu navegador. Desde ahí podrás completar la instalación de WordPress en el navegador.Instalación de WordPressUna vez configurado el servidor, el virtualhost y los permisos, es momento de acceder a la interfaz de instalación de WordPress y configurar el sitio. Aquí tienes los pasos detallados:Accede a la URL de instalaciónAbre tu navegador web y accede al dominio configurado en tu archivo /etc/hosts:http://wordpress.pablo.beerDeberías ver la pantalla inicial de configuración de WordPress:El instalador nos pide que elijamos un idioma para el sitio. Selecciona el deseado (por ejemplo, Español) y haz clic en Continuar.Configura la conexión con la base de datosEn la siguiente pantalla, deberás proporcionar los datos de conexión a la base de datos:  Nombre de la base de datos: wordpress_db (la base de datos que creaste).  Nombre de usuario: user (el usuario que configuraste).  Contraseña: La contraseña asignada al usuario.  Servidor de la base de datos: localhost.  Prefijo de tabla: Por defecto es wp_. Puedes cambiarlo si lo deseas, pero no es obligatorio.Haz clic en Enviar.Configura los datos del sitio webRellena el formulario con la información básica del sitio:  Título del sitio: El nombre de tu blog o página.  Nombre de usuario: El nombre para el administrador del sitio.  Contraseña: Una contraseña segura para el usuario administrador.  Correo electrónico: Un correo asociado al administrador.  Privacidad: Puedes elegir si deseas que los motores de búsqueda indexen tu sitio (puedes cambiar esto más adelante).Haz clic en Instalar WordPress.Accede al panel de administraciónCuando la instalación se complete, WordPress te redirigirá a la pantalla de inicio de sesión.Si queremos acceder al panel de administración lo haremos desde http://wordpress.pablo.beer/wp-admin. Ingresa tu nombre de usuario y contraseña creados en el paso anterior y ya estaríamos dentro.Primer blogUna vez dentro del panel de administración:  En el menú de la izquierda, haz clic en Entradas.  Luego, selecciona Añadir nueva.En la pantalla de creación de la entrada escribe el contenido de tu blog:  Título: Escribe un título para tu entrada, como por ejemplo Mi primera entrada en el blog.  Contenido: En el editor, puedes escribir el cuerpo de tu entrada. Puedes incluir texto, imágenes, enlaces, videos, etc.El editor de WordPress es muy intuitivo y funciona mediante bloques:  Haz clic en el botón + para añadir bloques como párrafos, encabezados, imágenes, etc.  Arrastra y organiza los bloques según necesites.Antes de publicar, puedes ajustar algunos parámetros:  Estado: Puedes guardar como borrador si no estás listo para publicarla.  Visibilidad: Define si la entrada será pública, privada o protegida con contraseña.  Publicación programada: Puedes programar la publicación para una fecha y hora futura.Cuando estés listo:  Haz clic en el botón Publicar en la parte superior derecha.  Confirma la publicación en el cuadro de diálogo que aparece.Tu entrada estará disponible en el blog y visible para los visitantes.Después de publicar, haz clic en el enlace Ver entrada para ver cómo se ve en tu sitio.Configurar URL amigables en WordPressLas URL amigables (también conocidas como “permalinks”) son direcciones web fáciles de leer y entender, lo que mejora la experiencia del usuario y también el SEO (posicionamiento en buscadores). En lugar de tener URLs como http://tu-sitio.com/?p=123, con URL amigables, las URLs serán algo como http://tu-sitio.com/mi-primera-entrada.Pasos para configurar URL amigables en WordPress1. Accede al panel de administración de WordPress. Abre tu navegador y accede a tu sitio de WordPress (por ejemplo: http://wordpress.tunombre.algo/wp-admin).2. Configura los enlaces permanentes.      En el menú lateral izquierdo, ve a Ajustes &gt; Enlaces permanentes.        Aquí verás diferentes opciones para configurar cómo se verán las URLs de tus entradas. Puedes elegir entre varias opciones como:                  Predeterminado: http://tu-sitio.com/?p=123                    Día y nombre: http://tu-sitio.com/2024/11/15/mi-primera-entrada                    Mes y nombre: http://tu-sitio.com/2024/11/mi-primera-entrada                    Nombre de la entrada: http://tu-sitio.com/mi-primera-entrada (más recomendado)                  Selecciona la opción Nombre de la entrada si deseas tener URLs amigables, y luego haz clic en Guardar cambios.  ¡Y eso es todo! Ahora tu sitio WordPress debería estar configurado para usar URL amigables, mejorando tanto la accesibilidad para los usuarios como el SEO. Con esta configuración, podrás disfrutar de una navegación más fluida y profesional.🚀"
  },
  
  {
    "title": "Comandos para programación de tareas",
    "url": "/posts/comandos-programacion/",
    "categories": "Sistemas, Automatización",
    "tags": "Automatización",
    "date": "2024-09-02 20:00:00 +0200",
    





    
    "snippet": "IntroducciónEn el entorno Linux, la programación de tareas es una habilidad fundamental que permite a los usuarios automatizar la ejecución de comandos y scripts en momentos específicos o en interv...",
    "content": "IntroducciónEn el entorno Linux, la programación de tareas es una habilidad fundamental que permite a los usuarios automatizar la ejecución de comandos y scripts en momentos específicos o en intervalos regulares. Esta capacidad no solo mejora la eficiencia, sino que también asegura que las tareas críticas se realicen sin intervención manual, lo que es especialmente útil para mantenimiento del sistema, copias de seguridad y actualizaciones programadas.Este post explorará los comandos más utilizados para programar tareas en Linux, tales como cron, at y systemd timers. Aprenderemos cómo configurarlos y utilizarlos de manera efectiva, proporcionando ejemplos prácticos que facilitarán la comprensión de su funcionamiento. Al final, tendrás las herramientas necesarias para automatizar tareas y optimizar tu flujo de trabajo en el sistema operativo Linux.1. SleepEl comando sleep en Linux se utiliza para pausar la ejecución de un proceso o script durante un período de tiempo especificado por el usuario. Este comando está disponible en todas las distribuciones de Linux, incluyendo Debian, y no requiere instalación adicional.Opciones y ParámetrosLas opciones más comunes para el comando sleep son:  -h o –help: Muestra información de ayuda sobre el comando sleep.  -v o –version: Muestra información sobre la versión del comando y detalles relacionados con su desarrollo.Los parámetros que se pueden utilizar con sleep para especificar el tiempo de pausa son:  s: Segundos (por defecto).  m: Minutos.  h: Horas.  d: Días.Es posible utilizar números enteros o decimales para especificar el tiempo de pausa.Ejemplos de UsoAquí hay algunos ejemplos de cómo se puede utilizar el comando sleep:  Pausar un proceso durante 10 segundos:  Pausar un proceso durante 2 minutos:  Pausar un proceso durante 1 hora y media:  Pausar un proceso durante 3 días:                             Pausar un proceso durante una combinación de tiempos (1 día, 2 horas, 3 minutos y 4 segundos):  Pausar un proceso durante 0.5 segundos (usando un número decimal):  Ejecutar varios comandos sleep de forma consecutiva o utilizar el operador &amp;&amp; para ejecutar otro comando después de sleep:  Este script se ejecutará en un bucle infinito, pero se pausará durante 10 minutos en cada iteración utilizando sleep.    echo \"Este script se ejecutará cada 10 minutos.\"while true; do# Comandos que deseas ejecutarsleep 10mdone      El comando sleep es especialmente útil en scripts de shell para introducir retrasosentre la ejecución de diferentes comandos, para reintentar operaciones fallidas después de un tiempo, o para esperar a que se cumplan ciertas condiciones, como la disponibilidad de una conexión de red.En resumen, sleep es una herramienta simple pero poderosa para controlar el flujode ejecución en scripts y procesos en sistemas operativos basados en Linux.2. WatchEl comando watch en Linux es una herramienta que permite a los usuariosmonitorizar continuamente los cambios en un archivo o el resultado de un comando en tiempo real. Este comando ejecuta otros comandos de forma repetitiva y muestra los resultados en tiempo real. Por defecto, watch ejecuta el comando especificado cada 2 segundos y muestra los resultados en la terminal.Opciones y ParámetrosLas opciones más comunes para el comando watch son:  -n segundos: Esta opción permite especificar el intervalo de tiempo en segundos entre cada ejecución del comando.  -d: Esta opción es usada para destacar las diferencias entre las actualizaciones  -t: Esta opción elimina el encabezado que muestra el intervalo, el comando y la hora actual  -g o –chgexit: Esta opción permite que watch termine la ejecución en el caso de que se haya modificado la salidaEjemplos de UsoAquí hay algunos ejemplos de cómo se puede utilizar el comando watch:  Monitorizar el uso de la memoria del servidor cada segundo:  Ejecutar el comando ls cada 5 segundos:  Resaltar las diferencias entre las actualizaciones al ejecutar el comando date:  Eliminar el encabezado al ejecutar el comando free:  Terminar la ejecución si el uso de memoria ha cambiado:  Observar el estado de la memoria con free, refrescando cada décima de segundo:  Observar las conexiones de red con netstat cada segundo:El comando watch es una herramienta muy útil para realizar monitorización en tiempo real en Linux, especialmente para observar la disponibilidad de recursos de red, CPU, memoria, entre otros.3. AtEl comando at en Linux es una herramienta que permite programar tareas únicas para que se ejecuten en un momento específico. Este comando es útil para programar tareas como apagar el sistema a una hora específica, realizar una copia de seguridad única, enviar un correo electrónico como recordatorio a la hora especificada, entre otras cosas.Opciones y ParámetrosLas opciones más comunes para el comando at son:  atq: Lista los trabajos programados.  atrm: Elimina trabajos programados. Se utiliza seguido del número detrabajo, por ejemplo, atrm.  at [hora] [fecha]: Programa una tarea para que se ejecute en la hora y fechaespecificadas.Ejemplos de UsoAquí hay algunos ejemplos de cómo se puede utilizar el comando at:  Programar una tarea para que se ejecute a las 10:00 PM:  Programar una tarea para que se ejecute a las 04:00 AM, copiando unarchivo, eliminándolo del directorio original y apagando el PC:    at 04:00cp /home/usuario/Escritorio/imagen.iso /home/usuario/isosrm /home/usuario/Escritorio/imagen.isoshutdown -h now        Luego presionar Ctrl + D para terminar de ingresar las instrucciones.    Listar los trabajos programados:                               Eliminar un trabajo programado, por ejemplo, el trabajo número 3:  Programar una tarea para que se ejecute a las 11:40 del 26 de febrero de 2023, listando los archivos en la ruta /tmp:    at 11:40 2023-02-26ls -ltr /tmp &gt; \"~/prueba_comando_at.txt\"echo 'finalizado ' &gt;&gt; \"~/prueba_comando_at.txt\"        Luego presionar ctrl + D para terminar de ingresar las instrucciones.  Ten en cuenta que para que el comando at funcione correctamente, lo tendremos que instalar con un sudo apt install at y debe estar corriendo el servicio atd (at daemon). Para habilitarlo en sistemas que usan systemd, puedes ejecutar: sudo systemctl enable –now atd.4. CrontabEl comando crontab en Linux es una herramienta que permite programar tareas para que se ejecuten automáticamente a intervalos regulares. Este comando es útil para automatizar tareas como realizar copias de seguridad, enviar correos electrónicos, limpiar directorios, entre otras cosas.Opciones y ParámetrosLas opciones más comunes para el comando crontab son:  crontab -e: Permite editar el archivo crontab del usuario actual.  crontab -l: Muestra la lista de trabajos programados para el usuario actual.  crontab -r: Elimina todos los trabajos programados para el usuario actual.  crontab -u [usuario] -e: Permite editar el archivo crontab de otro usuario (requiere privilegios de superusuario).Ejemplos de UsoAquí hay algunos ejemplos de cómo se puede utilizar el comando crontab:  Programar una tarea para que se ejecute todos los días a las 5:00 PM:    crontab -e0 17 * * * /ruta/del/script.sh        Luego presionar ctrl + X y luego Y para guardar y salir (si estás utilizando el editor nano).    Listar los trabajos programados:                               Eliminar todos los trabajos programados:  Programar una tarea para que se ejecute cada minuto:    crontab -e* * * * * /ruta/del/comando        Programar una tarea para que se ejecute cada lunes a las 6:30 AM:    crontab -e30 6 * * 1 /ruta/del/comando      En los ejemplos anteriores, la sintaxis de los cinco asteriscos en las entradas de crontab representa minuto (0-59), hora (0-23), día del mes (1-31), mes (1-12) y día de la semana (0-7, donde tanto 0 como 7 representan el domingo), respectivamente.5. ConclusiónEn resumen, los comandos sleep, watch, at y crontab son herramientas esenciales en sistemas operativos basados en Linux, como Debian, para la gestión del tiempo y la automatización de tareas.Estas herramientas proporcionan a los usuarios y administradores de sistemas unagran flexibilidad para programar y automatizar tareas, optimizando así el flujo detrabajo y la eficiencia del sistema.6. BibliografíaIONOSMontblanczoneHostgator"
  },
  
  {
    "title": "Creación de máquina virtual en VirtualBox con arranque dual",
    "url": "/posts/dual-boot/",
    "categories": "Sistemas, Virtualización",
    "tags": "Virtualización",
    "date": "2024-09-02 14:09:00 +0200",
    





    
    "snippet": "IntroducciónEn esta práctica, aprenderemos a crear una máquina virtual en VirtualBox que permita ejecutar dos sistemas operativos en modo de arranque dual: Windows y Debian Bookworm. El arranque du...",
    "content": "IntroducciónEn esta práctica, aprenderemos a crear una máquina virtual en VirtualBox que permita ejecutar dos sistemas operativos en modo de arranque dual: Windows y Debian Bookworm. El arranque dual es una técnica que nos permite elegir entre dos sistemas operativos al iniciar la máquina, lo que resulta muy útil para tener un entorno flexible y adaptable a diferentes necesidades de trabajo o pruebas. Exploraremos los pasos necesarios para instalar y configurar ambos sistemas operativos en la misma máquina virtual, asegurándonos de que puedan coexistir de manera eficiente y sin problemas de compatibilidad. ¡Comencemos!Requisitos Mínimos y RecomendadosLos requisitos específicos pueden variar según la versión de Windows yDebian que elijas, pero aquí tienes algunos requisitos generales:Para Windows (por ejemplo, Windows 10):  Mínimos: Procesador de 1 GHz, 1 GB de RAM (32 bits) o 2 GB deRAM (64 bits), 16 GB de espacio en disco duro, tarjeta gráficacompatible con DirectX 9.  Recomendados: Procesador de 2 GHz o superior, 4 GB de RAM omás, 64 GB de espacio en disco duro o más, tarjeta gráficacompatible con DirectX 11.Para Debian Bookworm (versión actualizada):  Mínimos: Procesador de 1 GHz, 1 GB de RAM, 10 GB de espacio endisco duro.  Recomendados: Procesador de 2 GHz o superior, 2 GB de RAM omás, 20 GB de espacio en disco duro o más.Requisitos Previos  Tener instalado Oracle VirtualBox en el equipo anfitrión.  Descargar las imágenes ISO de Windows y Debian Bookworm.Instalación1. Creación de la Máquina Virtual:  Abre VirtualBox.  Haga clic en “Nueva” para crear una nueva máquina virtual.  Ingresa un nombre para la máquina virtual (ejemplo: “DualBoot”).  Introduce la ISO de Windows descargada anteriormente y selecciona la versión adecuada (por ejemplo, “Windows 10 Pro de 64 bits”).  Configure la cantidad de memoria RAM asignada según los requisitos del sistema operativo Windows (en mi caso le asignaré 4096MB) y la cantidad de CPUs (en mi caso le pondré 4).  Crea un disco duro virtual y asigna un tamaño suficiente para ambos sistemas operativos (por ejemplo, 50 GB).Una vez creada la máquina, nos dirigimos a “Configuración” y en la pestaña “Sistema” deseleccionamos el disquete y dejamos seleccionadas la unidad óptica y el disco duro.Después de esto ya podemos iniciar la máquina virtual y empezar elproceso de instalación de Windows 10.2. Instalación de Windows  Seguimos las instrucciones de instalación de Windows  En la pestaña en la que nos pregunta que tipo de instalaciónqueremos elegimos “Personalizada: instalar solo Windows(avanzado)”, esto lo haremos para indicar en que parte del discoinstalaremos el sistema operativo.  Configure las opciones de idioma, zona horaria y cuenta de usuario.Después de esto ya lo deberíamos tener instalado.3. Liberación de discoTendremos que particionar el disco desde Windows para darle espacio mástarde en la instalación de Debian. Para ello seguiremos los estos pasos:  Nos dirigimos al apartado “Desfragmentar y optimizar unidades”Ahí analizaremos y optimizaremos el disco (C:) para seguidamentepoder desfragmentar el disco. Esto nos servirá a la hora de reducir elvolumen del disco principal.  Luego nos iremos al apartado “Crear y formatear particiones deldisco duro”Aquí haremos botón derecho sobre el disco duro (C:) y le daremos a“reducir volumen”, en este caso le asignaremos 20GB a la segundapartición en la cual instalaremos Debian 12.Una vez liberado y particionado el disco para darle espacio a Debian,apagamos la máquina virtual.4. Instalación de Debian Bookworm  Nos dirigimos a “Configuración” y en la pestaña de“Almacenamiento” sustituimos la imagen ISO de Windows por la deDebian 12 ya descargada anteriormente.  Seguimos las instrucciones de instalación de Debian como ya hemosvisto anteriormente, en la que configuraremos el nombre del host,crearemos una cuenta de usuario, idioma, etc.  Una vez llegamos a la configuración del particionado de disco,seleccionamos el método “Manual”, y seleccionamos el espacio libreque hemos dejado anteriormente, aquí nos dejará elegir entre crearuna partición nueva manualmente o particionar el espacio libre demanera automática, esta segunda opción es la que nos interesa. Nosdebe de quedar algo como esto:  En el apartado de selección de entorno gráfico podremos instalar elentorno que deseemos, en mi caso no instalaré ninguno. De todasformas, luego en la línea de comandos puedo instalar cualquierentorno con el comando “tasksel”.5.Configuración del Gestor de Arranque GRUB  Durante la instalación de Debian, se instalará GRUB, el gestor dearranque.  Asegúrese de que GRUB detecte automáticamente ambos sistemasoperativos (Windows y Debian) durante la instalación. Nos deberíasaltar un mensaje como este:  Esto permitirá que al iniciar la máquina virtual, puedas elegir entrelos dos sistemas operativos desde el menú de GRUB.6. Finalización de la Instalación  Reinicia la máquina virtual.  Deberías ver el menú de GRUB que te permite seleccionar entreWindows y Debian al iniciar.Y con esto ya habríamos terminado la creación de máquina virtual enVirtualBox con arranque dual."
  },
  
  {
    "title": "Compartición de carpetas",
    "url": "/posts/comparticion-carpetas/",
    "categories": "Redes, Compartición de archivos",
    "tags": "Compartición de archivos",
    "date": "2024-09-01 15:30:00 +0200",
    





    
    "snippet": "1. IntroducciónEn esta práctica se abordará la configuración y gestión de la compartición de carpetas entre diferentes sistemas operativos en una red local. La compartición de archivos es una tarea...",
    "content": "1. IntroducciónEn esta práctica se abordará la configuración y gestión de la compartición de carpetas entre diferentes sistemas operativos en una red local. La compartición de archivos es una tarea esencial en redes empresariales y domésticas, ya que permite a los usuarios acceder y gestionar recursos compartidos de manera eficiente, independientemente del sistema operativo que utilicen.El objetivo de esta práctica es demostrar cómo configurar la compartición de carpetas en diversas combinaciones de sistemas: de Windows a Windows, de Windows a Debian, de Debian a Windows, etc. Se utilizarán herramientas nativas y protocolos como Samba para garantizar la interoperabilidad entre estos sistemas.Al finalizar, se habrá aprendido a configurar adecuadamente permisos de acceso, seguridad y las mejores prácticas para la compartición de recursos en un entorno de red mixto.2. Windows a WindowsPara compartir carpetas entre dos máquinas físicas con Windows10, podemos utilizar la funcionalidad de red compartida de Windows.A continuación, te proporciono los pasos generales para hacerlo:2.1. Conexión de redAsegúrate de que ambas máquinas estén conectadas a lamisma red, ya sea mediante Wi-Fi o Ethernet. Esto es esencialpara que las computadoras se vean entre sí. En mi caso,realizaré la compartición de carpetas entre dos máquinasfísicas conectadas a una misma red Wi-Fi. Para saber nuestraIP nos dirigimos al “Cmd” y utilizamos el comando “ipconfig”.Aquí veremos diferentes IPv4, pero a mi me interesa eladaptador de LAN inalámbrica Wi-Fi:2.2. Habilitar el descubrimiento de redEn ambas máquinas, debes asegurarte de que la función de“Descubrimiento de red” esté habilitada. Para hacerlo: Ve al “Panel de control” &gt; “Redes y recursos compartidos”.En la parte izquierda, haz clic en “Cambiar la configuración deuso compartido avanzado”.Asegúrate de que la opción “Activar el uso compartido dearchivos e impresoras” esté habilitada y que la opción “Activarel descubrimiento de red” también esté habilitada.2.3. Compartir carpetasEn la máquina desde la cual deseas compartir carpetas, sigueestos pasos:  Navega a la carpeta que deseas compartir  Haz clic derecho en la carpeta y selecciona “Propiedades”.  Ve a la pestaña “Uso compartido” y haz clic en “Compartir”.  Elige a quién deseas compartir la carpeta. Puedes seleccionar “Todos” para que sea accesible para todos en la red o agregar usuarios específicos.  Define los permisos de acceso (lectura, escritura, etc.) según tus necesidades.  Haz clic en “Compartir” y luego en “Listo”.2.4. Acceso a la carpeta compartidaEn la otra máquina, para acceder a la carpeta compartida:  Abre el Explorador de Windows.  En la barra de direcciones, escribe \\”IP” (reemplaza “IP” por la ruta de la máquina desde la cual estás compartiendo la carpeta).  Deberías ver la carpeta compartida. Haz doble clic en ella y podrás acceder a su contenido.Es importante que ambas máquinas tengan configurado un grupo detrabajo común. Puedes verificar esto y cambiarlo en la configuración de redde cada máquina si es necesario. Además, asegúrate de que las cuentas deusuario en ambas máquinas tengan permisos para acceder a las carpetascompartidas si estás utilizando autenticación basada en cuentas de usuario.Ten en cuenta que estos son pasos generales y pueden variar según laconfiguración específica de tu red y tu sistema. Además, para acceder a lascarpetas compartidas en una red local, ambas máquinas deben estarencendidas y conectadas a la red al mismo tiempo.3. Windows a DebianPara compartir carpetas entre una máquina física con Windows 10 y unamáquina virtual Debian 11 se pueden utilizar diferentes métodos, pero en mi caso utilizaré Samba, en los que seguiré estos pasos:3.1. Configuración de la Máquina Virtual Debian 11Asegúrese de que la máquina virtual Debian 11 esté funcionandocorrectamente y tenga acceso a la red. Para ello tendremos quecambiar el adaptador de red en la configuración de la máquinavirtual, en este caso un adaptador puente.Después de esto, tendremos que comprobar que nuestras máquinashacen ping entre sí:Ping de Windows a DebianPing de Debian a WindowsInstale el paquete de Samba en Debian 11 si aún no está instalado.Puedes hacerlo ejecutando el siguiente comando en la terminal:Creamos la carpeta donde vamos a compartir los archivos.mkdir /home/pavlo/compartidachmod 777 /home/pavlo/compartidaEditamos el archivo de configuración de samba:nano /etc/samba/smb.confAl final del archivo insertamos el siguiente texto correspondiente a laconfiguración de nuestra carpeta compartida:[compartida]path = /home/pavlo/compartidacomment = Compartidaguest ok = yespublic = yeswritable = yesGuardamos los cambios y después reiniciamos el servicio con elcomando:service smbd restartDespués de esto creamos un documento de prueba y ya tendremoscreada una carpeta lista para compartir:En nuestro equipo con Windows nos dirigimos al apartado de red yen el navegador de archivos escribimos la IP que tengamos asignadaen Debian:Si se le solicita un nombre de usuario y una contraseña, ingrese lascredenciales de inicio de sesión de su máquina virtual Debian 11.Con esto realizado, ya podremos empezar a compartir archivos entre losdos sistemas operativos.Mencionar, que en este ejemplo hemos utilizado unos permisos para lacarpeta muy permisivos en el que cualquiera puede leer y escribir en eldirectorio.4. Debian a WindowsPara compartir carpetas de Debian a Windows tenemos que seguirexactamente los mismos pasos ya explicados en el apartado anterior.5. Debian a DebianPara compartir carpetas entre Debian y Debian hay que seguirprácticamente los mismos pasos ya explicados anteriormente. En mi casolo haré con dos máquinas virtuales entre sí. Para ello tendremos que seguir una serie de pasos:      En primer lugar y muy importante, comprobar que haya conectividad(ping) entre nuestras máquinas, en donde tendremos que configurarlas IPs para que ambas tengan coherencia. Después de ellorealizaremos la prueba y comprobamos si funciona:        Seguidamente tendremos que instalar Samba en ambas máquinas ycreamos la carpeta donde vamos a compartir los archivos.  mkdir /home/pavlo/compartidadebianchmod 777 /home/pavlo/compartidadebian  Editamos el archivo de configuración de samba:    nano /etc/samba/smb.conf      Al final del archivo insertamos el siguiente texto correspondiente a laconfiguración de nuestra carpeta compartida:[compartidadebian]path = /home/pavlo/compartidadebiancomment = Comparticion entre Debian y Debianguest ok = yespublic = yeswritable = yesGuardamos los cambios y después reiniciamos el servicio con elcomando:service smbd restart      Después de esto creamos un documento de prueba y ya tendremoscreada una carpeta lista para compartir:        Una vez configurado todo se seguirán los mismos sencillos pasos queen Windows estando en la misma red y utilizando el comandosmb://111.111.1.11  Y con esto ya habríamos hecho la compartición de carpetas entre Debian y Debian a través de Samba.6. Windows a AndroidUtilizando una aplicación llamada “fx file explorer” nos resultará muysencillo compartir carpetas entre Windows y Android.Como en todos los apartados anteriores tendremos que estar conectados ala misma red para que ambos dispositivos puedan realizar conectividadentre sí. En mi caso estarán conectados tanto mi portátil como mi teléfono a la red Wi-Fi de mi casa.Una vez instalada la aplicación y comprobado que ambos dispositivos están en la misma red, creamos una carpeta compartida en Windows dando los permisos que queramos como ya he explicado anteriormente. Despuésaccedemos al apartado de “Network” y agregamos un nuevo dispositivo enel que tendremos que poner la IP de nuestro dispositivo Windows.Una vez realizado todo esto lo único que queda es abrir la carpetacompartida con permisos y crear un archivo desde Android comprobandoque todo vaya bien.7. Debian y AndroidQuizás la forma más fácil de compartir archivos entre Android y Linux de forma inalámbrica sea descargando una aplicación FTP en un dispositivo Android. Ya que nos permite alojar rápidamente un servidor FTP improvisado en nuestro dispositivo Android, que luego puede aceptarconexiones remotas de forma inalámbrica.Antes de que podamos hablar sobre la configuración del servidor, deberáinstalar la aplicación WiFi FTP Server en su dispositivo Android. Parahacer esto, abra la aplicación Google Play Store en Android, busque“Servidor FTP WiFi” e instálalo.Después de estado tendremos que instalar Filezilla en Debian con elsiguiente comando:apt install FilezillaDentro de la aplicación de Android crearemos un servidor con la ubicación de donde queremos crear los archivos.Una vez creamos el servidor dentro de Filezilla ponemos los datos que nos da la aplicación para crear una conexión directa entre ambos dispositivos.Seguidamente le damos a “Subir” en el archivo o carpeta que queramoscompartir y así respectivamente con cualquier cosa que queramoscompartir entre ambos dispositivos."
  }
  
]

